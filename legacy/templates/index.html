<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/static/logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <title>Hallucinated Reference Checker</title>
    <style>
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --bg-tertiary: #fafafa;
            --text-primary: #333;
            --text-secondary: #666;
            --text-heading: #1a1a1a;
            --border-color: #ddd;
            --shadow-color: rgba(0,0,0,0.1);
            --link-color: #2563eb;
            --drop-zone-border: #9ca3af;
            --drop-zone-bg: #f9fafb;
            --drop-zone-active-bg: #eff6ff;
            --drop-zone-active-border: #2563eb;
            --input-readonly-bg: #f3f4f6;
            --input-readonly-text: #6b7280;
        }
        .dark {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #363636;
            --text-primary: #e5e5e5;
            --text-secondary: #a0a0a0;
            --text-heading: #f5f5f5;
            --border-color: #444;
            --shadow-color: rgba(0,0,0,0.3);
            --link-color: #60a5fa;
            --drop-zone-border: #555;
            --drop-zone-bg: #252525;
            --drop-zone-active-bg: #1e3a5f;
            --drop-zone-active-border: #60a5fa;
            --input-readonly-bg: #2a2a2a;
            --input-readonly-text: #9ca3af;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s, color 0.3s;
        }
        @media (min-width: 1200px) {
            body {
                max-width: 1100px;
            }
        }
        @media (min-width: 1600px) {
            body {
                max-width: 1400px;
            }
        }
        @media (min-width: 1900px) {
            body {
                max-width: 1600px;
            }
        }
        h1 {
            color: var(--text-heading);
            margin-bottom: 0.5rem;
        }
        .subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }
        .subtitle a {
            color: var(--link-color);
        }
        .upload-form {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            margin-bottom: 2rem;
        }
        /* Dark mode toggle */
        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: all 0.2s;
            z-index: 1000;
        }
        .theme-toggle:hover {
            transform: scale(1.1);
        }
        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--drop-zone-border);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--drop-zone-bg);
        }
        .drop-zone:hover {
            border-color: var(--link-color);
        }
        .drop-zone.drag-over {
            border-color: var(--drop-zone-active-border);
            background: var(--drop-zone-active-bg);
        }
        .drop-zone-text {
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        .drop-zone-hint {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .drop-zone-file {
            margin-top: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: inline-block;
            font-size: 0.9rem;
        }
        .drop-zone input[type="file"] {
            display: none;
        }
        /* PDF Preview Panel */
        .main-container {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        .main-content {
            flex: 1;
            min-width: 0;
        }
        .pdf-preview-panel {
            display: none;
            width: 450px;
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 2rem);
            overflow: hidden;
        }
        @media (min-width: 1200px) {
            .pdf-preview-panel {
                width: 500px;
            }
        }
        @media (min-width: 1600px) {
            .pdf-preview-panel {
                width: 600px;
            }
        }
        @media (min-width: 1900px) {
            .pdf-preview-panel {
                width: 700px;
            }
        }
        .pdf-preview-panel.visible {
            display: flex;
            flex-direction: column;
        }
        .pdf-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }
        .pdf-preview-header h3 {
            margin: 0;
            font-size: 0.95rem;
            color: var(--text-heading);
        }
        .pdf-preview-close {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            line-height: 1;
        }
        .pdf-preview-close:hover {
            color: var(--text-primary);
        }
        .pdf-preview-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }
        .pdf-preview-controls button {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        .pdf-preview-controls span {
            font-size: 0.85rem;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }
        .pdf-preview-container {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .pdf-preview-container canvas {
            max-width: 100%;
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        .pdf-toggle-btn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--link-color);
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px var(--shadow-color);
            z-index: 1001;
            display: none;
            transition: background 0.2s;
        }
        .pdf-toggle-btn:hover {
            background: #1d4ed8;
        }
        .dark .pdf-toggle-btn:hover {
            background: #3b82f6;
        }
        .pdf-toggle-btn.visible {
            display: block;
        }
        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }
            .pdf-preview-panel {
                width: 100%;
                position: static;
                max-height: 50vh;
            }
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .label-hint {
            font-weight: normal;
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        input[type="text"]::placeholder {
            color: var(--text-secondary);
        }
        .checkbox-group {
            margin-top: 0.5rem;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-weight: normal;
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .db-toggles {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem 1.5rem;
        }
        input[type="text"][readonly] {
            background-color: var(--input-readonly-bg);
            color: var(--input-readonly-text);
            cursor: not-allowed;
            opacity: 0.85;
        }
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #1d4ed8;
        }
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .cancel-btn {
            background: #dc2626;
            margin-top: 0.75rem;
        }
        .cancel-btn:hover {
            background: #b91c1c;
        }
        .progress-section {
            display: none;
            margin-top: 1rem;
        }
        .progress-section.visible {
            display: block;
        }
        .progress-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            color: #333;
        }
        .spinner-icon {
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .progress-bar-container {
            background: #e5e7eb;
            border-radius: 4px;
            height: 8px;
            margin-bottom: 0.75rem;
            overflow: hidden;
        }
        .progress-bar {
            background: #2563eb;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-status {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }
        .progress-current {
            font-size: 0.85rem;
            color: #888;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .progress-results {
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            background: var(--bg-tertiary);
        }
        .progress-result-item {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .progress-result-item:last-child {
            border-bottom: none;
        }
        .progress-result-verified {
            color: #16a34a;
        }
        .progress-result-mismatch {
            color: #ca8a04;
        }
        .progress-result-notfound {
            color: #dc2626;
        }
        .results {
            display: none;
        }
        .results.visible {
            display: block;
        }
        .summary {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            margin-bottom: 1.5rem;
        }
        .summary h2 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--text-heading);
        }
        .stats {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .stat-verified .stat-value { color: #16a34a; }
        .stat-mismatch .stat-value { color: #ca8a04; }
        .stat-notfound .stat-value { color: #dc2626; }
        .stat-doi-issue .stat-value { color: #9333ea; }
        .stat-arxiv-issue .stat-value { color: #0891b2; }
        .stat-retracted .stat-value { color: #b91c1c; }
        .stat-skipped .stat-value { color: #6b7280; }
        .skipped-details {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }
        .problematic-percent {
            color: #dc2626;
            font-size: 0.95rem;
            font-weight: 500;
            margin-top: 0.75rem;
        }
        .problematic-percent.clean {
            color: #16a34a;
        }
        .hallucinations {
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            overflow: hidden;
        }
        .hallucinations h2 {
            margin: 0;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-heading);
        }
        .reference {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .reference:last-child {
            border-bottom: none;
        }
        .reference-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            word-break: break-word;
        }
        .reference-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }
        .status-not-found {
            background: #fef2f2;
            color: #dc2626;
        }
        .status-mismatch {
            background: #fefce8;
            color: #ca8a04;
        }
        .author-comparison {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }
        .author-comparison h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .author-list {
            margin: 0;
            padding-left: 1.25rem;
        }
        .scholar-link {
            display: inline-block;
            color: #2563eb;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .scholar-link:hover {
            text-decoration: underline;
        }
        .reference-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-top: 0.5rem;
        }
        .mark-safe-btn {
            background: none;
            border: 1px solid #16a34a;
            color: #16a34a;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mark-safe-btn:hover {
            background: #16a34a;
            color: white;
        }
        .report-btn {
            background: none;
            border: 1px solid #6b7280;
            color: #6b7280;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        .report-btn:hover {
            background: #6b7280;
            color: white;
        }
        .find-in-pdf-btn {
            background: none;
            border: 1px solid #8b5cf6;
            color: #8b5cf6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: none;
        }
        .find-in-pdf-btn.visible {
            display: inline-block;
        }
        .find-in-pdf-btn:hover {
            background: #8b5cf6;
            color: white;
        }
        .find-in-pdf-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .retry-btn {
            background: none;
            border: 1px solid #f59e0b;
            color: #92400e;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: all 0.2s;
        }
        .retry-btn:hover {
            background: #f59e0b;
            color: white;
        }
        .retry-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .retry-btn.retrying {
            background: #fef3c7;
        }
        .download-report-section {
            display: none;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e5e7eb;
        }
        .download-report-section.visible {
            display: block;
        }
        .download-report-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .download-report-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .download-report-btn:hover {
            background: #b91c1c;
        }
        .download-report-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .format-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .format-selector label {
            font-weight: normal;
            color: #666;
            margin-bottom: 0;
        }
        .format-selector select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: none;
        }
        .error-message.visible {
            display: block;
        }
        .no-hallucinations {
            padding: 2rem;
            text-align: center;
            color: #16a34a;
        }
        .verified-section {
            border-top: 1px solid var(--border-color);
            margin-top: 1rem;
        }
        .verified-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: #f0fdf4;
            cursor: pointer;
            user-select: none;
            color: #16a34a;
            font-weight: 500;
        }
        .verified-header:hover {
            background: #dcfce7;
        }
        .verified-toggle {
            transition: transform 0.2s;
        }
        .verified-section.expanded .verified-toggle {
            transform: rotate(180deg);
        }
        .verified-list {
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        .verified-section.expanded .verified-list {
            display: block;
        }
        .verified-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            gap: 1rem;
        }
        .verified-item:last-child {
            border-bottom: none;
        }
        .verified-title {
            flex: 1;
            word-break: break-word;
        }
        .verified-source {
            color: #16a34a;
            font-size: 0.85rem;
            white-space: nowrap;
            text-decoration: none;
        }
        a.verified-source:hover {
            text-decoration: underline;
        }
        .doi-badge {
            background: #dbeafe;
            color: #1d4ed8;
            font-size: 0.75rem;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            text-decoration: none;
            margin-left: 0.5rem;
            white-space: nowrap;
        }
        .doi-badge:hover {
            background: #bfdbfe;
        }
        .dark .doi-badge {
            background: #1e3a5f;
            color: #93c5fd;
        }
        .dark .doi-badge:hover {
            background: #1e4976;
        }
        .doi-issue {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        .doi-issue-invalid {
            background: #fee2e2;
            border-color: #ef4444;
        }
        .dark .doi-issue {
            background: #451a03;
            border-color: #d97706;
        }
        .dark .doi-issue-invalid {
            background: #450a0a;
            border-color: #dc2626;
        }
        /* Multi-file archive styles */
        .file-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .file-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: #f9fafb;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            user-select: none;
        }
        .file-header:hover {
            background: #f3f4f6;
        }
        .file-header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .file-name {
            font-weight: 600;
            word-break: break-word;
        }
        .file-status-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .file-status-ok {
            background: #dcfce7;
            color: #16a34a;
        }
        .file-status-issues {
            background: #fef2f2;
            color: #dc2626;
        }
        .file-status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        .file-toggle {
            font-size: 1.2rem;
            transition: transform 0.2s ease;
            color: #6b7280;
        }
        .file-toggle.expanded {
            transform: rotate(180deg);
        }
        .file-content {
            display: none;
            padding: 1.5rem;
            border-top: 1px solid #eee;
        }
        .file-content.visible {
            display: block;
        }
        .file-error {
            color: #dc2626;
            background: #fef2f2;
            padding: 1rem;
            border-radius: 4px;
        }
        .file-summary {
            margin-bottom: 1rem;
        }
        .file-summary .stats {
            gap: 1.5rem;
        }
        .file-summary .stat-value {
            font-size: 1.5rem;
        }
        .multi-file-header {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }
        .multi-file-header h2 {
            margin: 0 0 0.5rem 0;
        }
        .multi-file-header .file-count {
            color: #666;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .logo {
            width: 100px;
            height: 100px;
            object-fit: contain;
        }
        .header-text h1 {
            margin: 0 0 0.25rem 0;
        }
        .header-text .subtitle {
            margin: 0;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">üåô</button>
    <div class="header">
        <img src="/static/logo.png" alt="Logo" class="logo">
        <div class="header-text">
            <h1>Hallucinated Reference Checker</h1>
            <p class="subtitle">Upload a PDF to check for potentially hallucinated or incorrect references</p>
        </div>
    </div>
    <p class="subtitle">Inspired by Madison Akles' <a href="https://madisonakles.github.io/checker.html">in-browser hallucination checker</a> | <a href="https://github.com/gianlucasb/hallucinator">Project GitHub</a></p>

    <!--
    <div style="margin-bottom: 1rem; padding: 0.75rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;">
        <strong>OpenReview Disabled:</strong> On Nov 27, 2025, bad actors <a href="https://blog.iclr.cc/2025/12/03/iclr-2026-response-to-security-incident/" style="color: #92400e;">exploited an API vulnerability</a> to deanonymize 45% of ICLR 2026 submissions (~10,000 papers), exposing reviewers, authors, and area chairs. The leaked data was used to harass reviewers, offer bribes, and coordinate collusion between authors and reviewers‚Äîa direct attack on the integrity of peer review. This happened while the ML community was already dealing with a flood of LLM-generated slop submissions. The OpenReview API is currently unreachable. This incident is exactly why tools like this need to exist.
    </div>
    -->

    <div class="main-container">
    <div class="main-content">
    <div class="upload-form">
        <form id="analyzeForm">
            <div class="form-group">
                <label>PDF File or Archive (.zip, .tar.gz)</label>
                <div class="drop-zone" id="dropZone">
                    <input type="file" id="pdfFile" name="pdf" accept=".pdf,.zip,.tar.gz,.tgz" required>
                    <div class="drop-zone-text">üìÑ Drag & drop your file here</div>
                    <div class="drop-zone-hint">or click to browse</div>
                    <div class="drop-zone-file" id="selectedFile" style="display: none;"></div>
                </div>
            </div>
            <div class="form-group">
                <label for="dblpOfflinePath">
                    DBLP Database Offline Path
                    <span class="label-hint">(optional, if  <code>DBLP_OFFLINE_PATH</code> is set it will be shown here)</span>
                </label>
                <input type="text" id="dblpOfflinePath" name="dblp_offline_path" value="{{ dblp_offline_path }}" placeholder="unset" readonly />
            </div>
            <div class="form-group">
                <label for="openalexKey">
                    OpenAlex API Key
                    <span class="label-hint">(optional, improves coverage)</span>
                </label>
                <input type="text" id="openalexKey" name="openalex_key" placeholder="Enter your OpenAlex API key">
            </div>
            <div class="form-group">
                <label for="s2ApiKey">
                    Semantic Scholar API Key
                    <span class="label-hint">(optional, avoids rate limiting)</span>
                </label>
                <input type="text" id="s2ApiKey" name="s2_api_key" placeholder="Enter your Semantic Scholar API key">
            </div>
            <div class="form-group checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="checkOpenalexAuthors" name="check_openalex_authors" value="true">
                    <span>Check author mismatches from OpenAlex</span>
                    <span class="label-hint">(off by default due to false positives)</span>
                </label>
            </div>
            <div class="form-group">
                <label>
                    Database Sources
                    <span class="label-hint">(uncheck to skip ‚Äî <a href="#" id="dbToggleAll">select/unselect all</a>)</span>
                </label>
                <div class="db-toggles">
                    <label class="checkbox-label"><input type="checkbox" data-db="CrossRef" checked><span>CrossRef</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="arXiv" checked><span>arXiv</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="DBLP" checked><span>DBLP</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="Semantic Scholar" checked><span>Semantic Scholar</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="SSRN" checked><span>SSRN</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="ACL Anthology" checked><span>ACL Anthology</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="NeurIPS" checked><span>NeurIPS</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="Europe PMC" checked><span>Europe PMC</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="PubMed" checked><span>PubMed</span></label>
                    <label class="checkbox-label"><input type="checkbox" data-db="OpenAlex" checked><span>OpenAlex</span></label>
                </div>
            </div>
            <button type="submit" id="submitBtn">Analyze References</button>
        </form>
        <div class="progress-section" id="progressSection">
            <div class="progress-header">
                <div class="spinner-icon"></div>
                <span id="progressHeaderText">Analyzing references...</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-status" id="progressStatus">Extracting references...</div>
            <div class="progress-current" id="progressCurrent"></div>
            <div class="progress-results" id="progressResults"></div>
            <button type="button" class="cancel-btn" id="cancelBtn">Cancel Analysis</button>
        </div>
        <div class="error-message" id="errorMessage"></div>
    </div>

    <div class="results" id="results">
        <div class="summary">
            <h2>Summary</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">Analyzed</div>
                </div>
                <div class="stat stat-verified">
                    <div class="stat-value" id="verifiedCount">0</div>
                    <div class="stat-label">Verified</div>
                </div>
                <div class="stat stat-mismatch">
                    <div class="stat-value" id="mismatchCount">0</div>
                    <div class="stat-label">Author Mismatches</div>
                </div>
                <div class="stat stat-notfound">
                    <div class="stat-value" id="notfoundCount">0</div>
                    <div class="stat-label">Not Found</div>
                </div>
                <div class="stat stat-doi-issue" id="doiIssueStat" style="display: none;">
                    <div class="stat-value" id="doiIssueCount">0</div>
                    <div class="stat-label">DOI Issues</div>
                </div>
                <div class="stat stat-arxiv-issue" id="arxivIssueStat" style="display: none;">
                    <div class="stat-value" id="arxivIssueCount">0</div>
                    <div class="stat-label">arXiv Issues</div>
                </div>
                <div class="stat stat-retracted" id="retractedStat" style="display: none;">
                    <div class="stat-value" id="retractedCount">0</div>
                    <div class="stat-label">Retracted</div>
                </div>
                <div class="stat stat-skipped">
                    <div class="stat-value" id="skippedCount">0</div>
                    <div class="stat-label">Skipped</div>
                </div>
            </div>
            <div class="skipped-details" id="skippedDetails"></div>
            <div class="problematic-percent" id="problematicPercent"></div>
            <div class="download-report-section" id="downloadReportSection">
                <div class="download-report-container">
                    <button class="download-report-btn" id="downloadReportBtn" onclick="downloadReport()">
                        üì• Download Report
                    </button>
                    <div class="format-selector">
                        <label for="reportFormat">Format:</label>
                        <select id="reportFormat">
                            <option value="html">HTML</option>
                            <option value="txt">Plain Text</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="hallucinations" id="hallucinations">
            <h2>Potential Hallucinations</h2>
            <div id="hallucinationList"></div>
        </div>

        <div class="hallucinations doi-issues-section" id="doiIssuesSection" style="display: none;">
            <h2 style="color: #9333ea;">DOI Issues</h2>
            <p class="doi-issues-description" style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.9rem;">
                These references have problematic DOIs - the DOI doesn't resolve, or points to a different paper.
            </p>
            <div id="doiIssuesList"></div>
        </div>

        <div class="hallucinations arxiv-issues-section" id="arxivIssuesSection" style="display: none;">
            <h2 style="color: #0891b2;">arXiv Issues</h2>
            <p class="arxiv-issues-description" style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.9rem;">
                These references have problematic arXiv IDs - the ID doesn't resolve, or points to a different paper.
            </p>
            <div id="arxivIssuesList"></div>
        </div>

        <div class="hallucinations retracted-section" id="retractedSection" style="display: none;">
            <h2 style="color: #b91c1c;">‚ö†Ô∏è Retracted Papers</h2>
            <p class="retracted-description" style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.9rem;">
                These referenced papers have been retracted or have an expression of concern. Consider removing or replacing these citations.
            </p>
            <div id="retractedList"></div>
        </div>
    </div>
    </div><!-- end main-content -->

    <!-- PDF Preview Panel -->
    <div class="pdf-preview-panel" id="pdfPreviewPanel">
        <div class="pdf-preview-header">
            <h3>üìÑ PDF Preview</h3>
            <button class="pdf-preview-close" id="pdfPreviewClose" title="Close preview">&times;</button>
        </div>
        <div class="pdf-preview-controls">
            <button id="pdfPrevPage" title="Previous page">‚óÄ</button>
            <span id="pdfPageInfo">Page 1 / 1</span>
            <button id="pdfNextPage" title="Next page">‚ñ∂</button>
        </div>
        <div class="pdf-preview-container" id="pdfPreviewContainer"></div>
    </div>
    </div><!-- end main-container -->

    <!-- Floating button to show PDF preview -->
    <button class="pdf-toggle-btn" id="pdfToggleBtn">üìÑ Show PDF</button>

    <script>
        const form = document.getElementById('analyzeForm');
        const submitBtn = document.getElementById('submitBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        let currentAbortController = null;
        const progressStatus = document.getElementById('progressStatus');
        const progressCurrent = document.getElementById('progressCurrent');
        const progressResults = document.getElementById('progressResults');
        const progressHeaderText = document.getElementById('progressHeaderText');
        const errorMessage = document.getElementById('errorMessage');
        const results = document.getElementById('results');
        const openalexKeyInput = document.getElementById('openalexKey');
        const s2ApiKeyInput = document.getElementById('s2ApiKey');
        const checkOpenalexAuthorsInput = document.getElementById('checkOpenalexAuthors');

        // Load saved settings from localStorage
        const savedOpenalexKey = localStorage.getItem('openalexKey');
        if (savedOpenalexKey) {
            openalexKeyInput.value = savedOpenalexKey;
        }
        const savedS2Key = localStorage.getItem('s2ApiKey');
        if (savedS2Key) {
            s2ApiKeyInput.value = savedS2Key;
        }
        const savedCheckOpenalexAuthors = localStorage.getItem('checkOpenalexAuthors');
        if (savedCheckOpenalexAuthors === 'true') {
            checkOpenalexAuthorsInput.checked = true;
        }

        // Restore disabled databases from localStorage
        const savedDisabledDbs = localStorage.getItem('disabledDbs');
        if (savedDisabledDbs) {
            try {
                const disabledSet = new Set(JSON.parse(savedDisabledDbs));
                document.querySelectorAll('[data-db]').forEach(cb => {
                    if (disabledSet.has(cb.getAttribute('data-db'))) {
                        cb.checked = false;
                    }
                });
            } catch (e) {
                localStorage.removeItem('disabledDbs');
            }
        }

        // Select/unselect all database toggles
        document.getElementById('dbToggleAll').addEventListener('click', (e) => {
            e.preventDefault();
            const boxes = document.querySelectorAll('[data-db]');
            const allChecked = Array.from(boxes).every(cb => cb.checked);
            boxes.forEach(cb => cb.checked = !allChecked);
        });

        // Cookie helpers
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = `${name}=${value}; expires=${expires}; path=/; SameSite=Lax`;
        }

        // Dark mode toggle (light mode is default)
        const themeToggle = document.getElementById('themeToggle');
        const savedTheme = getCookie('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark');
            themeToggle.textContent = '‚òÄÔ∏è';
        }
        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            const isDark = document.body.classList.contains('dark');
            themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            setCookie('theme', isDark ? 'dark' : 'light');
        });

        // Drag and drop file upload
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('pdfFile');
        const selectedFileDiv = document.getElementById('selectedFile');

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                updateSelectedFile(files[0]);
            }
        });

        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                updateSelectedFile(fileInput.files[0]);
            }
        });

        function updateSelectedFile(file) {
            selectedFileDiv.textContent = 'üìé ' + file.name;
            selectedFileDiv.style.display = 'inline-block';
            // Load PDF preview if it's a PDF file
            if (file.name.toLowerCase().endsWith('.pdf')) {
                loadPdfPreview(file);
            }
        }

        // PDF Preview functionality
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null;
        let currentPage = 1;
        let pdfScale = 1.5;
        let referenceStartPage = 1;

        const pdfPreviewPanel = document.getElementById('pdfPreviewPanel');
        const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
        const pdfPageInfo = document.getElementById('pdfPageInfo');
        const pdfToggleBtn = document.getElementById('pdfToggleBtn');
        const pdfPreviewClose = document.getElementById('pdfPreviewClose');

        document.getElementById('pdfPrevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderPage(currentPage);
            }
        });

        document.getElementById('pdfNextPage').addEventListener('click', () => {
            if (pdfDoc && currentPage < pdfDoc.numPages) {
                currentPage++;
                renderPage(currentPage);
            }
        });

        pdfPreviewClose.addEventListener('click', () => {
            pdfPreviewPanel.classList.remove('visible');
            pdfToggleBtn.textContent = 'üìÑ Show PDF';
        });

        pdfToggleBtn.addEventListener('click', () => {
            const isVisible = pdfPreviewPanel.classList.toggle('visible');
            pdfToggleBtn.textContent = isVisible ? 'üìÑ Hide PDF' : 'üìÑ Show PDF';
        });

        async function loadPdfPreview(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                // Find the page containing "References" section
                referenceStartPage = await findReferencesPage(pdfDoc);
                currentPage = referenceStartPage;

                renderPage(currentPage);
                pdfToggleBtn.classList.add('visible');
                updateFindInPdfButtons();
            } catch (error) {
                console.error('Error loading PDF:', error);
            }
        }

        async function findReferencesPage(pdf) {
            // Search from the end of the document (references are usually at the end)
            for (let i = pdf.numPages; i >= 1; i--) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const text = textContent.items.map(item => item.str).join(' ');

                // Look for "References" or "Bibliography" header
                if (/\bReferences\b|\bBibliography\b|\bREFERENCES\b/i.test(text)) {
                    return i;
                }
            }
            return pdf.numPages; // Default to last page if not found
        }

        // Store current highlight for redrawing on zoom
        let currentHighlight = null;

        async function renderPage(pageNum, highlight = null) {
            if (!pdfDoc) return;

            // Store highlight for redrawing on zoom
            if (highlight !== undefined) {
                currentHighlight = highlight;
            }

            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: pdfScale });

            // Create canvas
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            // Clear container and add canvas
            pdfPreviewContainer.innerHTML = '';
            pdfPreviewContainer.appendChild(canvas);

            // Render PDF page
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            // Draw highlight box if provided
            if (currentHighlight && currentHighlight.pageNum === pageNum) {
                const h = currentHighlight;
                context.strokeStyle = '#f59e0b';
                context.lineWidth = 3;
                context.fillStyle = 'rgba(245, 158, 11, 0.2)';

                const x = h.x * pdfScale;
                const y = h.y * pdfScale;
                const width = h.width * pdfScale;
                const height = h.height * pdfScale;

                // Draw filled rectangle with border
                context.fillRect(x - 5, y - 5, width + 10, height + 10);
                context.strokeRect(x - 5, y - 5, width + 10, height + 10);
            }

            // Update page info
            pdfPageInfo.textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;
        }

        function showPdfPreview() {
            if (pdfDoc) {
                pdfPreviewPanel.classList.add('visible');
                pdfToggleBtn.textContent = 'üìÑ Hide PDF';
            }
        }

        function handleFindInPdf(btn) {
            const title = btn.dataset.title || '';
            let authors = [];
            try {
                authors = JSON.parse(btn.dataset.authors || '[]');
            } catch (e) {
                console.error('Error parsing authors:', e);
            }
            findReferenceInPdf(title, authors);
        }

        async function findReferenceInPdf(title, authors = []) {
            if (!pdfDoc) {
                alert('No PDF loaded. Please upload a PDF file first.');
                return;
            }

            // Extract author last names for anchor search
            const authorLastNames = authors
                .map(a => {
                    // Handle "F. LastName" or "FirstName LastName" formats
                    const parts = a.trim().split(/\s+/);
                    // Get the last part that's not an initial
                    for (let i = parts.length - 1; i >= 0; i--) {
                        if (parts[i].length > 2 && !parts[i].endsWith('.')) {
                            return parts[i].toLowerCase().replace(/[^\w]/g, '');
                        }
                    }
                    return null;
                })
                .filter(n => n && n.length > 2);

            // Extract title words for verification
            const titleWords = title
                .toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(w => w.length > 3)
                .slice(0, 8);

            if (titleWords.length === 0 && authorLastNames.length === 0) {
                alert('Could not extract search terms from reference.');
                return;
            }

            // Search pages from end to start (references are at the end)
            for (let pageNum = pdfDoc.numPages; pageNum >= 1; pageNum--) {
                try {
                    const result = await searchPageForReference(pageNum, authorLastNames, titleWords);
                    if (result.found && result.bounds) {
                        currentPage = pageNum;

                        const highlight = {
                            pageNum: pageNum,
                            x: result.bounds.x,
                            y: result.bounds.y,
                            width: result.bounds.width,
                            height: result.bounds.height
                        };

                        await renderPage(pageNum, highlight);
                        showPdfPreview();

                        const scrollY = result.bounds.y * pdfScale;
                        setTimeout(() => {
                            pdfPreviewContainer.scrollTop = Math.max(0, scrollY - 100);
                        }, 100);
                        return;
                    }
                } catch (error) {
                    console.error(`Error searching page ${pageNum}:`, error);
                }
            }

            alert('Reference not found in PDF. The text may be formatted differently.');
        }

        async function searchPageForReference(pageNum, authorLastNames, titleWords) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                const viewport = page.getViewport({ scale: 1 });

                // Collect text items with their bounding boxes
                const textItems = [];
                for (const item of textContent.items) {
                    if (!item.str) continue;
                    const x = item.transform ? item.transform[4] : 0;
                    const y = item.transform ? viewport.height - item.transform[5] : 0;
                    const width = item.width || 100;
                    const height = item.height || 12;
                    const normalized = item.str.toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
                    if (normalized) {
                        textItems.push({ text: normalized, x, y, width, height, original: item.str, index: textItems.length });
                    }
                }

                if (textItems.length === 0) {
                    return { found: false, bounds: null };
                }

                // Helper to get bounds with padding - only for items that match
                function getBoundsForItems(items) {
                    if (items.length === 0) return null;
                    const padding = 5;
                    const minX = Math.min(...items.map(it => it.x)) - padding;
                    const minY = Math.min(...items.map(it => it.y)) - padding;
                    const maxX = Math.max(...items.map(it => it.x + it.width)) + padding;
                    const maxY = Math.max(...items.map(it => it.y + it.height)) + padding;
                    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                }

                // Helper to find items that match any of the search words
                function getMatchingItems(items, words) {
                    return items.filter(it => words.some(w => it.text.includes(w)));
                }

                // Helper to find items near a position (same column + Y range)
                function getItemsNearby(anchorItem, yRange = 50) {
                    const anchorX = anchorItem.x;
                    const anchorY = anchorItem.y;
                    // Items in same column (X within 200px) and Y range
                    return textItems.filter(it =>
                        Math.abs(it.y - anchorY) < yRange &&
                        Math.abs(it.x - anchorX) < 200
                    );
                }

                // Helper to count matching words in items
                function countMatchingWords(items, words) {
                    const itemText = items.map(it => it.text).join(' ');
                    return words.filter(w => itemText.includes(w)).length;
                }

                let bestMatch = null;
                let bestScore = 0;
                let bestMatchingItems = [];

                // Combine all search terms
                const allSearchTerms = [...authorLastNames, ...titleWords];

                // Strategy 1: Use author last names as anchors (most reliable)
                if (authorLastNames.length > 0) {
                    const primaryAuthor = authorLastNames[0];

                    for (let i = 0; i < textItems.length; i++) {
                        if (textItems[i].text.includes(primaryAuthor)) {
                            const anchorItem = textItems[i];
                            // Get items in same column and nearby vertically
                            const nearbyItems = getItemsNearby(anchorItem, 60);

                            // Count matches
                            let authorMatches = 0;
                            const matchingItems = [];

                            for (const author of authorLastNames) {
                                const found = nearbyItems.find(it => it.text.includes(author));
                                if (found) {
                                    authorMatches++;
                                    if (!matchingItems.includes(found)) matchingItems.push(found);
                                }
                            }

                            let titleMatches = 0;
                            for (const word of titleWords) {
                                const found = nearbyItems.find(it => it.text.includes(word));
                                if (found) {
                                    titleMatches++;
                                    if (!matchingItems.includes(found)) matchingItems.push(found);
                                }
                            }

                            const score = authorMatches * 3 + titleMatches;

                            if (score > bestScore && titleMatches >= 2) {
                                bestScore = score;
                                bestMatchingItems = matchingItems;
                                // Bounding box only around matching items
                                bestMatch = getBoundsForItems(matchingItems);
                            }
                        }
                    }
                }

                // Strategy 2: Fall back to title-word clustering if no author match
                if (!bestMatch && titleWords.length > 0) {
                    const anchorWord = titleWords.reduce((a, b) => a.length > b.length ? a : b);

                    for (let i = 0; i < textItems.length; i++) {
                        if (textItems[i].text.includes(anchorWord)) {
                            const anchorItem = textItems[i];
                            const nearbyItems = getItemsNearby(anchorItem, 50);

                            const matchingItems = [];
                            let titleMatches = 0;
                            for (const word of titleWords) {
                                const found = nearbyItems.find(it => it.text.includes(word));
                                if (found) {
                                    titleMatches++;
                                    if (!matchingItems.includes(found)) matchingItems.push(found);
                                }
                            }

                            const score = titleMatches;

                            if (score > bestScore && titleMatches >= Math.ceil(titleWords.length * 0.4)) {
                                bestScore = score;
                                bestMatchingItems = matchingItems;
                                bestMatch = getBoundsForItems(matchingItems);
                            }
                        }
                    }
                }

                // Require minimum match quality
                const minRequired = authorLastNames.length > 0 ? 3 : Math.ceil(titleWords.length * 0.4);
                return {
                    found: bestScore >= minRequired,
                    bounds: bestMatch,
                    score: bestScore
                };
            } catch (error) {
                console.error(`Error in searchPageForReference for page ${pageNum}:`, error);
                return { found: false, bounds: null, score: 0 };
            }
        }

        // Show/hide "Find in PDF" buttons based on whether PDF is loaded
        function updateFindInPdfButtons() {
            const buttons = document.querySelectorAll('.find-in-pdf-btn');
            buttons.forEach(btn => {
                if (pdfDoc) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
            });
        }

        // Track live results during streaming
        let liveResults = [];
        let totalRefs = 0;
        let isArchive = false;
        let archiveFileCount = 0;
        let currentFileIndex = 0;
        let currentFilename = '';

        // Store current report data for download
        let currentReportData = null;
        let uploadedFilename = '';

        function createScholarLink(title) {
            const encoded = encodeURIComponent(title);
            return `https://scholar.google.com/scholar?q=${encoded}`;
        }

        function createReportUrl(ref) {
            const repoUrl = 'https://github.com/gianlucasb/hallucinator';

            let issueTitle = `False positive: ${ref.title.substring(0, 60)}${ref.title.length > 60 ? '...' : ''}`;

            let issueBody = `## False Positive Report\n\n`;
            issueBody += `**Extracted Title:** ${ref.title}\n\n`;

            if (ref.ref_authors && ref.ref_authors.length > 0) {
                issueBody += `**Extracted Authors:** ${ref.ref_authors.join(', ')}\n\n`;
            }

            issueBody += `**Error Type:** ${ref.error_type === 'not_found' ? 'Not found in any database' : 'Author mismatch'}\n\n`;

            if (ref.error_type === 'author_mismatch' && ref.source) {
                issueBody += `**Found on:** ${ref.source}\n`;
                if (ref.found_authors && ref.found_authors.length > 0) {
                    issueBody += `**Database Authors:** ${ref.found_authors.join(', ')}\n\n`;
                }
            }

            issueBody += `---\n\n`;
            issueBody += `### Additional context\n`;
            issueBody += `<!-- Please add any additional information that might help, such as:\n`;
            issueBody += `- Link to the actual paper (DOI, arXiv, etc.)\n`;
            issueBody += `- The correct title if it was extracted incorrectly\n`;
            issueBody += `- Why this is a false positive\n`;
            issueBody += `-->\n\n`;

            const encodedTitle = encodeURIComponent(issueTitle);
            const encodedBody = encodeURIComponent(issueBody);

            return `${repoUrl}/issues/new?title=${encodedTitle}&body=${encodedBody}&labels=false-positive`;
        }

        function renderHallucination(ref) {
            const div = document.createElement('div');
            div.className = 'reference';

            let statusClass = ref.error_type === 'not_found' ? 'status-not-found' : 'status-mismatch';
            let statusText = ref.error_type === 'not_found'
                ? 'Not found in any database'
                : `Author mismatch (found on ${ref.source})`;

            let authorHtml = '';
            if (ref.error_type === 'author_mismatch') {
                authorHtml = `
                    <div class="author-comparison">
                        <h4>Authors in PDF:</h4>
                        <ul class="author-list">
                            ${ref.ref_authors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                        </ul>
                        <h4 style="margin-top: 0.75rem;">Authors in ${escapeHtml(ref.source)}:</h4>
                        <ul class="author-list">
                            ${ref.found_authors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Show DOI issues if present
            let doiHtml = '';
            if (ref.doi_info && ref.doi_info.status !== 'verified') {
                const doiClass = ref.doi_info.status === 'invalid' ? 'doi-issue doi-issue-invalid' : 'doi-issue';
                let doiMessage = '';
                if (ref.doi_info.status === 'invalid') {
                    doiMessage = `‚ùå Invalid DOI: ${escapeHtml(ref.doi_info.message)}`;
                } else if (ref.doi_info.status === 'title_mismatch') {
                    doiMessage = `‚ö†Ô∏è DOI mismatch: Points to "${escapeHtml(ref.doi_info.doi_title || 'different paper')}"`;
                } else if (ref.doi_info.status === 'author_mismatch') {
                    doiMessage = `‚ö†Ô∏è DOI author mismatch: Title matches but authors differ`;
                }
                doiHtml = `
                    <div class="${doiClass}">
                        <strong>DOI:</strong> <a href="https://doi.org/${escapeHtml(ref.doi_info.doi)}" target="_blank">${escapeHtml(ref.doi_info.doi)}</a><br>
                        ${doiMessage}
                    </div>
                `;
            }

            // Show which databases timed out
            let timeoutHtml = '';
            if (ref.failed_dbs && ref.failed_dbs.length > 0) {
                const failedDbsJson = JSON.stringify(ref.failed_dbs).replace(/"/g, '&quot;');
                const refAuthorsJson = JSON.stringify(ref.ref_authors || []).replace(/"/g, '&quot;');
                timeoutHtml = `
                    <div class="timeout-info" style="margin-top: 0.5rem; padding: 0.375rem 0.75rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.25rem; color: #92400e; font-size: 0.85rem;">
                        <span class="timeout-text">‚ö†Ô∏è Timed out: ${ref.failed_dbs.map(db => escapeHtml(db)).join(', ')}</span>
                        <button class="retry-btn" onclick="retryReference(this)"
                                data-title="${escapeHtml(ref.title).replace(/"/g, '&quot;')}"
                                data-failed-dbs="${failedDbsJson}"
                                data-ref-authors="${refAuthorsJson}">
                            ‚Üª Retry
                        </button>
                    </div>
                `;
            }

            div.innerHTML = `
                <div class="reference-title">${escapeHtml(ref.title)}</div>
                <div class="reference-status ${statusClass}">${statusText}</div>
                ${doiHtml}
                ${timeoutHtml}
                ${authorHtml}
                <div class="reference-actions">
                    <a href="${createScholarLink(ref.title)}" target="_blank" class="scholar-link">
                        Search on Google Scholar &rarr;
                    </a>
                    <button class="mark-safe-btn" onclick="markAsSafe(this, '${escapeHtml(ref.title).replace(/'/g, "\\'")}')">
                        ‚úì Mark as safe
                    </button>
                    <a href="${createReportUrl(ref)}" target="_blank" class="report-btn">
                        ‚öë Report false positive
                    </a>
                    <button class="find-in-pdf-btn" onclick="handleFindInPdf(this)"
                            data-title="${escapeHtml(ref.title).replace(/"/g, '&quot;')}"
                            data-authors='${JSON.stringify(ref.ref_authors || []).replace(/'/g, "&#39;")}'>
                        üìç Find in PDF
                    </button>
                </div>
            `;

            return div;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function markAsSafe(button, title) {
            const referenceDiv = button.closest('.reference');

            // Determine if we're in archive mode (inside a file-section) or single file mode
            const fileSection = referenceDiv.closest('.file-section');
            const isArchiveMode = fileSection !== null;

            // Find the container for this file's references
            const container = isArchiveMode
                ? fileSection.querySelector('.file-content')
                : document.getElementById('hallucinationList');

            // Find or create the verified section
            let verifiedSection;
            if (isArchiveMode) {
                // For archive mode, add verified section inside the file content
                verifiedSection = container.querySelector('.verified-section');
                if (!verifiedSection) {
                    verifiedSection = document.createElement('div');
                    verifiedSection.className = 'verified-section';
                    verifiedSection.innerHTML = `
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (0)</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list"></div>
                    `;
                    container.appendChild(verifiedSection);
                }
            } else {
                // For single file mode, place verified section after DOI issues section
                const doiIssuesSection = document.getElementById('doiIssuesSection');
                verifiedSection = doiIssuesSection.parentNode.querySelector('.verified-section');
                if (!verifiedSection) {
                    verifiedSection = document.createElement('div');
                    verifiedSection.className = 'verified-section';
                    verifiedSection.innerHTML = `
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (0)</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list"></div>
                    `;
                    doiIssuesSection.parentNode.insertBefore(verifiedSection, doiIssuesSection.nextSibling);
                }
            }

            // Add to verified list
            const verifiedList = verifiedSection.querySelector('.verified-list');
            const item = document.createElement('div');
            item.className = 'verified-item';
            item.innerHTML = `
                <span class="verified-title">${escapeHtml(title)}</span>
                <span class="verified-source" style="color: #16a34a;">Marked as safe</span>
            `;
            verifiedList.appendChild(item);

            // Update verified count in the section header
            const verifiedCount = verifiedList.querySelectorAll('.verified-item').length;
            const countText = verifiedSection.querySelector('.verified-count-text');
            if (countText) {
                countText.textContent = `Verified References (${verifiedCount})`;
            } else {
                // Fallback for existing header format
                const header = verifiedSection.querySelector('.verified-header span:first-child');
                if (header) header.textContent = `Verified References (${verifiedCount})`;
            }

            // Determine if this was not_found or mismatch based on status class
            const statusEl = referenceDiv.querySelector('.reference-status');
            const wasMismatch = statusEl && statusEl.classList.contains('status-mismatch');

            // Remove from problematic list
            referenceDiv.remove();

            // Update summary counts - different locations for archive vs single mode
            if (isArchiveMode) {
                // Archive mode: update stats within the file section
                const statsContainer = fileSection.querySelector('.file-summary .stats');
                if (statsContainer) {
                    const verifiedStat = statsContainer.querySelector('.stat-verified .stat-value');
                    const mismatchStat = statsContainer.querySelector('.stat-mismatch .stat-value');
                    const notfoundStat = statsContainer.querySelector('.stat-notfound .stat-value');

                    if (verifiedStat) {
                        verifiedStat.textContent = parseInt(verifiedStat.textContent) + 1;
                    }
                    if (wasMismatch && mismatchStat) {
                        mismatchStat.textContent = parseInt(mismatchStat.textContent) - 1;
                    } else if (notfoundStat) {
                        notfoundStat.textContent = parseInt(notfoundStat.textContent) - 1;
                    }
                }

                // Update file's problematic percentage
                updateFileProblematicPercent(fileSection);
            } else {
                // Single file mode: update main summary
                const verifiedCountEl = document.getElementById('verifiedCount');
                const mismatchCountEl = document.getElementById('mismatchCount');
                const notfoundCountEl = document.getElementById('notfoundCount');

                if (verifiedCountEl) {
                    verifiedCountEl.textContent = parseInt(verifiedCountEl.textContent) + 1;
                }
                if (wasMismatch && mismatchCountEl) {
                    mismatchCountEl.textContent = parseInt(mismatchCountEl.textContent) - 1;
                } else if (notfoundCountEl) {
                    notfoundCountEl.textContent = parseInt(notfoundCountEl.textContent) - 1;
                }

                // Update problematic percentage
                updateProblematicPercent();
            }

            // Check if all references in this container are now verified
            const remainingProblematic = container.querySelectorAll('.reference').length;
            if (remainingProblematic === 0 && !container.querySelector('.no-hallucinations')) {
                // Add "all verified" message before the verified section
                const noHallucinations = document.createElement('div');
                noHallucinations.className = 'no-hallucinations';
                noHallucinations.textContent = 'All references verified!';
                container.insertBefore(noHallucinations, verifiedSection);
            }
        }

        function markDoiIssueSafe(button, title) {
            const referenceDiv = button.closest('.reference');
            if (!referenceDiv) return;

            // Get the DOI issues section and list
            const doiIssuesSection = document.getElementById('doiIssuesSection');
            const doiIssuesList = document.getElementById('doiIssuesList');

            // Find or create verified section (after DOI issues section)
            let verifiedSection = doiIssuesSection.parentNode.querySelector('.verified-section');
            if (!verifiedSection) {
                verifiedSection = document.createElement('div');
                verifiedSection.className = 'verified-section';
                verifiedSection.innerHTML = `
                    <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                        <span class="verified-count-text">Verified References (0)</span>
                        <span class="verified-toggle">‚ñº</span>
                    </div>
                    <div class="verified-list"></div>
                `;
                doiIssuesSection.parentNode.insertBefore(verifiedSection, doiIssuesSection.nextSibling);
            }

            // Add to verified list
            const verifiedList = verifiedSection.querySelector('.verified-list');
            const item = document.createElement('div');
            item.className = 'verified-item';
            item.innerHTML = `
                <span class="verified-title">${escapeHtml(title)}</span>
                <span class="verified-source" style="color: #16a34a;">Marked as safe</span>
            `;
            verifiedList.appendChild(item);

            // Update verified count in the section header
            const verifiedCount = verifiedList.querySelectorAll('.verified-item').length;
            const countText = verifiedSection.querySelector('.verified-count-text');
            if (countText) {
                countText.textContent = `Verified References (${verifiedCount})`;
            }

            // Update DOI issues stat
            const doiIssueCountEl = document.getElementById('doiIssueCount');
            if (doiIssueCountEl) {
                const currentCount = parseInt(doiIssueCountEl.textContent) || 0;
                doiIssueCountEl.textContent = Math.max(0, currentCount - 1);
            }

            // Update verified count stat
            const verifiedCountEl = document.getElementById('verifiedCount');
            if (verifiedCountEl) {
                verifiedCountEl.textContent = parseInt(verifiedCountEl.textContent) + 1;
            }

            // Remove from DOI issues list
            referenceDiv.remove();

            // Hide DOI issues section if empty
            const remainingDoiIssues = doiIssuesList.querySelectorAll('.reference').length;
            if (remainingDoiIssues === 0) {
                doiIssuesSection.style.display = 'none';
            }

            // Update problematic percentage
            updateProblematicPercent();
        }

        function markArxivIssueSafe(button, title) {
            const referenceDiv = button.closest('.reference');
            if (!referenceDiv) return;

            // Get the arXiv issues section and list
            const arxivIssuesSection = document.getElementById('arxivIssuesSection');
            const arxivIssuesList = document.getElementById('arxivIssuesList');

            // Find or create verified section (after arXiv issues section)
            let verifiedSection = arxivIssuesSection.parentNode.querySelector('.verified-section');
            if (!verifiedSection) {
                verifiedSection = document.createElement('div');
                verifiedSection.className = 'verified-section';
                verifiedSection.innerHTML = `
                    <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                        <span class="verified-count-text">Verified References (0)</span>
                        <span class="verified-toggle">‚ñº</span>
                    </div>
                    <div class="verified-list"></div>
                `;
                arxivIssuesSection.parentNode.insertBefore(verifiedSection, arxivIssuesSection.nextSibling);
            }

            // Add to verified list
            const verifiedList = verifiedSection.querySelector('.verified-list');
            const item = document.createElement('div');
            item.className = 'verified-item';
            item.innerHTML = `
                <span class="verified-title">${escapeHtml(title)}</span>
                <span class="verified-source" style="color: #16a34a;">Marked as safe</span>
            `;
            verifiedList.appendChild(item);

            // Update verified count in the section header
            const verifiedCount = verifiedList.querySelectorAll('.verified-item').length;
            const countText = verifiedSection.querySelector('.verified-count-text');
            if (countText) {
                countText.textContent = `Verified References (${verifiedCount})`;
            }

            // Update arXiv issues stat
            const arxivIssueCountEl = document.getElementById('arxivIssueCount');
            if (arxivIssueCountEl) {
                const currentCount = parseInt(arxivIssueCountEl.textContent) || 0;
                arxivIssueCountEl.textContent = Math.max(0, currentCount - 1);
            }

            // Update verified count stat
            const verifiedCountEl = document.getElementById('verifiedCount');
            if (verifiedCountEl) {
                verifiedCountEl.textContent = parseInt(verifiedCountEl.textContent) + 1;
            }

            // Remove from arXiv issues list
            referenceDiv.remove();

            // Hide arXiv issues section if empty
            const remainingArxivIssues = arxivIssuesList.querySelectorAll('.reference').length;
            if (remainingArxivIssues === 0) {
                arxivIssuesSection.style.display = 'none';
            }

            // Update problematic percentage
            updateProblematicPercent();
        }

        function updateFileProblematicPercent(fileSection) {
            const statsContainer = fileSection.querySelector('.file-summary .stats');
            const percentEl = fileSection.querySelector('.file-summary .problematic-percent');

            if (!statsContainer || !percentEl) return;

            const total = parseInt(statsContainer.querySelector('.stat:first-child .stat-value')?.textContent) || 0;
            const notFound = parseInt(statsContainer.querySelector('.stat-notfound .stat-value')?.textContent) || 0;
            const mismatched = parseInt(statsContainer.querySelector('.stat-mismatch .stat-value')?.textContent) || 0;
            const problematic = notFound + mismatched;

            if (total > 0) {
                const percent = ((problematic / total) * 100).toFixed(1);
                if (problematic === 0) {
                    percentEl.textContent = 'All references verified!';
                    percentEl.className = 'problematic-percent clean';
                } else {
                    percentEl.textContent = `${percent}% problematic (${problematic} of ${total})`;
                    percentEl.className = 'problematic-percent';
                }
            }
        }

        function updateProblematicPercent() {
            const problematicPercent = document.getElementById('problematicPercent');
            const totalCountEl = document.getElementById('totalCount');

            if (!problematicPercent || !totalCountEl) return;

            const total = parseInt(totalCountEl.textContent) || 0;

            // Count unique problematic references by title (no double-counting)
            // A reference may appear in multiple sections (e.g., hallucination list AND DOI issues)
            const problematicTitles = new Set();

            // Collect titles from all problem sections
            document.querySelectorAll('#hallucinationList .reference').forEach(ref => {
                const title = ref.querySelector('h3')?.textContent?.trim();
                if (title) problematicTitles.add(title);
            });
            document.querySelectorAll('#doiIssuesList .reference').forEach(ref => {
                const title = ref.querySelector('h3')?.textContent?.trim();
                if (title) problematicTitles.add(title);
            });
            document.querySelectorAll('#arxivIssuesList .reference').forEach(ref => {
                const title = ref.querySelector('h3')?.textContent?.trim();
                if (title) problematicTitles.add(title);
            });
            document.querySelectorAll('#retractedList .reference').forEach(ref => {
                const title = ref.querySelector('h3')?.textContent?.trim();
                if (title) problematicTitles.add(title);
            });

            const problematic = problematicTitles.size;

            if (total > 0) {
                const percent = ((problematic / total) * 100).toFixed(1);
                if (problematic === 0) {
                    problematicPercent.textContent = 'All references verified!';
                    problematicPercent.className = 'problematic-percent clean';
                } else {
                    problematicPercent.textContent = `${percent}% of references are problematic...`;
                    problematicPercent.className = 'problematic-percent';
                }
            }
        }

        async function retryReference(button) {
            const title = button.dataset.title;
            const failedDbs = JSON.parse(button.dataset.failedDbs);
            const refAuthors = JSON.parse(button.dataset.refAuthors);

            // Get API keys from form
            const openalexKey = document.getElementById('openalexKey')?.value?.trim() || null;
            const s2ApiKey = document.getElementById('s2ApiKey')?.value?.trim() || null;
            const checkOpenalexAuthors = document.getElementById('checkOpenalexAuthors')?.checked || false;

            // Update button state
            button.disabled = true;
            button.classList.add('retrying');
            const originalText = button.textContent;
            button.textContent = 'Retrying...';

            try {
                const response = await fetch('/retry', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title,
                        ref_authors: refAuthors,
                        failed_dbs: failedDbs,
                        openalex_key: openalexKey,
                        s2_api_key: s2ApiKey,
                        check_openalex_authors: checkOpenalexAuthors,
                    }),
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Retry failed');
                }

                const referenceDiv = button.closest('.reference');
                const timeoutInfo = button.closest('.timeout-info');

                if (result.status === 'verified') {
                    // Move to verified section
                    moveToVerified(referenceDiv, title, result.source, result.paper_url);
                } else if (result.status === 'author_mismatch') {
                    // Update to show author mismatch instead
                    updateToAuthorMismatch(referenceDiv, title, result, refAuthors);
                } else if (result.failed_dbs && result.failed_dbs.length > 0) {
                    // Still have timeouts - update the timeout info
                    const timeoutText = timeoutInfo.querySelector('.timeout-text');
                    timeoutText.textContent = `‚ö†Ô∏è Timed out: ${result.failed_dbs.join(', ')}`;
                    button.dataset.failedDbs = JSON.stringify(result.failed_dbs);
                    button.disabled = false;
                    button.classList.remove('retrying');
                    button.textContent = originalText;
                } else {
                    // No more timeouts but still not found - remove timeout section
                    timeoutInfo.remove();
                }
            } catch (error) {
                console.error('Retry failed:', error);
                button.textContent = 'Retry failed';
                button.classList.remove('retrying');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }

        function moveToVerified(referenceDiv, title, source, paperUrl) {
            const fileSection = referenceDiv.closest('.file-section');
            const isArchiveMode = fileSection !== null;
            const container = isArchiveMode
                ? fileSection.querySelector('.file-content')
                : document.getElementById('hallucinationList');

            // Find or create verified section
            let verifiedSection;
            if (isArchiveMode) {
                // For archive mode, add verified section inside the file content
                verifiedSection = container.querySelector('.verified-section');
                if (!verifiedSection) {
                    verifiedSection = document.createElement('div');
                    verifiedSection.className = 'verified-section';
                    verifiedSection.innerHTML = `
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (0)</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list"></div>
                    `;
                    container.appendChild(verifiedSection);
                }
            } else {
                // For single file mode, place verified section after DOI issues section
                const doiIssuesSection = document.getElementById('doiIssuesSection');
                verifiedSection = doiIssuesSection.parentNode.querySelector('.verified-section');
                if (!verifiedSection) {
                    verifiedSection = document.createElement('div');
                    verifiedSection.className = 'verified-section';
                    verifiedSection.innerHTML = `
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (0)</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list"></div>
                    `;
                    doiIssuesSection.parentNode.insertBefore(verifiedSection, doiIssuesSection.nextSibling);
                }
            }

            // Add to verified list
            const verifiedList = verifiedSection.querySelector('.verified-list');
            const item = document.createElement('div');
            item.className = 'verified-item';
            const sourceLink = paperUrl
                ? `<a href="${escapeHtml(paperUrl)}" target="_blank" class="verified-source">${escapeHtml(source)} ‚Üó</a>`
                : `<span class="verified-source">${escapeHtml(source)}</span>`;
            item.innerHTML = `
                <span class="verified-title">${escapeHtml(title)}</span>
                ${sourceLink}
            `;
            verifiedList.appendChild(item);

            // Update verified count
            const verifiedCount = verifiedList.querySelectorAll('.verified-item').length;
            const countText = verifiedSection.querySelector('.verified-count-text');
            if (countText) {
                countText.textContent = `Verified References (${verifiedCount})`;
            } else {
                const header = verifiedSection.querySelector('.verified-header span:first-child');
                if (header) header.textContent = `Verified References (${verifiedCount})`;
            }

            // Check if was mismatch or not_found
            const statusEl = referenceDiv.querySelector('.reference-status');
            const wasMismatch = statusEl && statusEl.classList.contains('status-mismatch');

            // Remove reference
            referenceDiv.remove();

            // Update counts
            if (isArchiveMode) {
                const statsContainer = fileSection.querySelector('.file-summary .stats');
                if (statsContainer) {
                    const verifiedStat = statsContainer.querySelector('.stat-verified .stat-value');
                    const mismatchStat = statsContainer.querySelector('.stat-mismatch .stat-value');
                    const notfoundStat = statsContainer.querySelector('.stat-notfound .stat-value');
                    if (verifiedStat) verifiedStat.textContent = parseInt(verifiedStat.textContent) + 1;
                    if (wasMismatch && mismatchStat) mismatchStat.textContent = parseInt(mismatchStat.textContent) - 1;
                    else if (notfoundStat) notfoundStat.textContent = parseInt(notfoundStat.textContent) - 1;
                }
                updateFileProblematicPercent(fileSection);
            } else {
                const verifiedCountEl = document.getElementById('verifiedCount');
                const mismatchCountEl = document.getElementById('mismatchCount');
                const notfoundCountEl = document.getElementById('notfoundCount');
                if (verifiedCountEl) verifiedCountEl.textContent = parseInt(verifiedCountEl.textContent) + 1;
                if (wasMismatch && mismatchCountEl) mismatchCountEl.textContent = parseInt(mismatchCountEl.textContent) - 1;
                else if (notfoundCountEl) notfoundCountEl.textContent = parseInt(notfoundCountEl.textContent) - 1;
                updateProblematicPercent();
            }

            // Check if all done
            const remaining = container.querySelectorAll('.reference').length;
            if (remaining === 0 && !container.querySelector('.no-hallucinations')) {
                const noHallucinations = document.createElement('div');
                noHallucinations.className = 'no-hallucinations';
                noHallucinations.textContent = 'All references verified!';
                container.insertBefore(noHallucinations, verifiedSection);
            }
        }

        function updateToAuthorMismatch(referenceDiv, title, result, refAuthors) {
            // Update status
            const statusEl = referenceDiv.querySelector('.reference-status');
            const wasNotFound = statusEl && statusEl.classList.contains('status-not-found');

            statusEl.className = 'reference-status status-mismatch';
            statusEl.textContent = `Author mismatch (found on ${result.source})`;

            // Remove timeout info
            const timeoutInfo = referenceDiv.querySelector('.timeout-info');
            if (timeoutInfo) timeoutInfo.remove();

            // Add author comparison if not already present
            let authorComparison = referenceDiv.querySelector('.author-comparison');
            if (!authorComparison) {
                authorComparison = document.createElement('div');
                authorComparison.className = 'author-comparison';
                const actionsDiv = referenceDiv.querySelector('.reference-actions');
                if (actionsDiv) {
                    referenceDiv.insertBefore(authorComparison, actionsDiv);
                } else {
                    referenceDiv.appendChild(authorComparison);
                }
            }
            authorComparison.innerHTML = `
                <h4>Authors in PDF:</h4>
                <ul class="author-list">
                    ${refAuthors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                </ul>
                <h4 style="margin-top: 0.75rem;">Authors in ${escapeHtml(result.source)}:</h4>
                <ul class="author-list">
                    ${result.found_authors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                </ul>
            `;

            // Update counts if status changed from not_found to mismatch
            if (wasNotFound) {
                const fileSection = referenceDiv.closest('.file-section');
                const isArchiveMode = fileSection !== null;

                if (isArchiveMode) {
                    const statsContainer = fileSection.querySelector('.file-summary .stats');
                    if (statsContainer) {
                        const mismatchStat = statsContainer.querySelector('.stat-mismatch .stat-value');
                        const notfoundStat = statsContainer.querySelector('.stat-notfound .stat-value');
                        if (mismatchStat) mismatchStat.textContent = parseInt(mismatchStat.textContent) + 1;
                        if (notfoundStat) notfoundStat.textContent = parseInt(notfoundStat.textContent) - 1;
                    }
                } else {
                    const mismatchCountEl = document.getElementById('mismatchCount');
                    const notfoundCountEl = document.getElementById('notfoundCount');
                    if (mismatchCountEl) mismatchCountEl.textContent = parseInt(mismatchCountEl.textContent) + 1;
                    if (notfoundCountEl) notfoundCountEl.textContent = parseInt(notfoundCountEl.textContent) - 1;
                }
            }
        }

        function downloadReport() {
            if (!currentReportData) return;

            const format = document.getElementById('reportFormat').value;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');

            // Get base filename without extension
            let baseFilename = uploadedFilename || 'report';
            baseFilename = baseFilename.replace(/\.(pdf|zip|tar\.gz|tgz)$/i, '');

            let content, filename, mimeType;

            if (format === 'html') {
                content = generateHtmlReport(currentReportData);
                filename = `${baseFilename}-hallucination-report.html`;
                mimeType = 'text/html';
            } else {
                content = generateTxtReport(currentReportData);
                filename = `${baseFilename}-hallucination-report.txt`;
                mimeType = 'text/plain';
            }

            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateHtmlReport(data) {
            const notFound = data.results.filter(r => r.status === 'not_found');
            const mismatched = data.results.filter(r => r.status === 'author_mismatch');
            const verified = data.results.filter(r => r.status === 'verified');
            const retracted = data.results.filter(r => r.retraction_info && r.retraction_info.retracted);
            const timestamp = new Date().toLocaleString();

            function refHtml(ref, idx) {
                const fileInfo = ref.filename ? `<div style="color:#666;font-size:0.85rem;margin-bottom:0.25rem">üìÑ ${escapeHtml(ref.filename)}</div>` : '';
                const citation = ref.raw_citation
                    ? `<div class="citation">${escapeHtml(ref.raw_citation)}</div>`
                    : '';
                const authors = (ref.ref_authors || []).length > 0
                    ? `<div class="authors">Extracted authors: ${(ref.ref_authors || []).map(a => escapeHtml(a)).join(', ')}</div>`
                    : '';
                const sourceInfo = ref.source
                    ? (ref.paper_url
                        ? `<div class="source">Source: <a href="${escapeHtml(ref.paper_url)}">${escapeHtml(ref.source)}</a></div>`
                        : `<div class="source">Source: ${escapeHtml(ref.source)}</div>`)
                    : '';
                const doiInfo = ref.doi_info && ref.doi_info.doi
                    ? `<div class="doi">DOI: <a href="https://doi.org/${escapeHtml(ref.doi_info.doi)}">${escapeHtml(ref.doi_info.doi)}</a></div>`
                    : '';
                const arxivInfo = ref.arxiv_info && ref.arxiv_info.arxiv_id
                    ? `<div class="arxiv">arXiv: <a href="https://arxiv.org/abs/${escapeHtml(ref.arxiv_info.arxiv_id)}">${escapeHtml(ref.arxiv_info.arxiv_id)}</a></div>`
                    : '';
                const retractionInfo = ref.retraction_info && ref.retraction_info.retracted
                    ? `<div class="retracted">‚ö† RETRACTED: ${escapeHtml(ref.retraction_info.reason || 'No reason given')}</div>`
                    : '';
                const failedDbs = (ref.failed_dbs || []).length > 0
                    ? `<div class="failed-dbs">Databases that failed/timed out: ${ref.failed_dbs.map(d => escapeHtml(d)).join(', ')}</div>`
                    : '';

                let mismatchDetail = '';
                if (ref.status === 'author_mismatch') {
                    mismatchDetail = `
        <div class="author-comparison">
            <h4>Authors in PDF:</h4>
            <ul>${(ref.ref_authors || []).map(a => `<li>${escapeHtml(a)}</li>`).join('')}</ul>
            <h4>Authors in ${escapeHtml(ref.source)}:</h4>
            <ul>${(ref.found_authors || []).map(a => `<li>${escapeHtml(a)}</li>`).join('')}</ul>
        </div>`;
                }

                return `
    <div class="reference ${ref.status}">
        ${fileInfo}
        <div class="reference-title">${idx + 1}. ${escapeHtml(ref.title)}</div>
        ${citation}${authors}${sourceInfo}${doiInfo}${arxivInfo}${retractionInfo}${failedDbs}${mismatchDetail}
    </div>`;
            }

            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reference Analysis Report - ${escapeHtml(uploadedFilename)}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 0 auto; padding: 2rem; color: #1f2937; }
        h1 { color: #1f2937; }
        h2 { margin-top: 2rem; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        .file-info { background: #e5e7eb; padding: 0.75rem 1rem; border-radius: 4px; margin-bottom: 1rem; }
        .summary { background: #f5f5f5; padding: 1rem; border-radius: 8px; margin-bottom: 2rem; }
        .stats { display: flex; gap: 2rem; flex-wrap: wrap; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        .stat-label { color: #666; font-size: 0.9rem; }
        .reference { background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; }
        .reference.not_found { border-left: 4px solid #dc2626; }
        .reference.author_mismatch { border-left: 4px solid #ca8a04; }
        .reference.verified { border-left: 4px solid #16a34a; }
        .reference-title { font-weight: 600; margin-bottom: 0.5rem; }
        .citation { color: #374151; font-size: 0.9rem; margin-bottom: 0.5rem; padding: 0.5rem; background: #f3f4f6; border-radius: 4px; font-style: italic; }
        .authors { color: #4b5563; font-size: 0.9rem; margin-bottom: 0.25rem; }
        .source { color: #4b5563; font-size: 0.9rem; margin-bottom: 0.25rem; }
        .source a { color: #2563eb; }
        .doi, .arxiv { font-size: 0.85rem; color: #6b7280; margin-bottom: 0.25rem; }
        .doi a, .arxiv a { color: #2563eb; }
        .retracted { color: #dc2626; font-weight: 600; margin-top: 0.5rem; }
        .failed-dbs { color: #92400e; font-size: 0.85rem; margin-top: 0.25rem; }
        .author-comparison { background: #f9fafb; padding: 1rem; border-radius: 4px; margin-top: 0.5rem; }
        .author-comparison h4 { margin: 0 0 0.5rem 0; font-size: 0.85rem; color: #666; }
        .footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; color: #666; font-size: 0.85rem; }
    </style>
</head>
<body>
    <h1>Reference Analysis Report</h1>
    <div class="file-info">üìÑ <strong>File:</strong> ${escapeHtml(uploadedFilename)}</div>
    <p>Generated: ${timestamp}</p>

    <div class="summary">
        <h2 style="margin-top:0;border:none;padding:0;">Summary</h2>
        <div class="stats">
            <div class="stat"><div class="stat-value">${data.summary.total}</div><div class="stat-label">Analyzed</div></div>
            <div class="stat"><div class="stat-value" style="color:#16a34a">${data.summary.verified}</div><div class="stat-label">Verified</div></div>
            <div class="stat"><div class="stat-value" style="color:#ca8a04">${data.summary.mismatched}</div><div class="stat-label">Author Mismatches</div></div>
            <div class="stat"><div class="stat-value" style="color:#dc2626">${data.summary.not_found}</div><div class="stat-label">Not Found</div></div>
            <div class="stat"><div class="stat-value">${data.summary.skipped}</div><div class="stat-label">Skipped</div></div>
        </div>
    </div>
`;

            // Not Found
            if (notFound.length > 0) {
                html += `<h2 style="color:#dc2626;">Not Found (${notFound.length})</h2>\n`;
                notFound.forEach((ref, idx) => { html += refHtml(ref, idx); });
            }

            // Author Mismatches
            if (mismatched.length > 0) {
                html += `<h2 style="color:#ca8a04;">Author Mismatches (${mismatched.length})</h2>\n`;
                mismatched.forEach((ref, idx) => { html += refHtml(ref, idx); });
            }

            // Retracted (only if not already shown above)
            const retractedVerified = retracted.filter(r => r.status === 'verified');
            if (retractedVerified.length > 0) {
                html += `<h2 style="color:#dc2626;">Retracted Papers (${retractedVerified.length})</h2>\n`;
                retractedVerified.forEach((ref, idx) => { html += refHtml(ref, idx); });
            }

            // Verified
            html += `<h2 style="color:#16a34a;">Verified References (${verified.length})</h2>\n`;
            if (verified.length === 0) {
                html += '<p>No references were verified.</p>';
            } else {
                verified.filter(r => !(r.retraction_info && r.retraction_info.retracted)).forEach((ref, idx) => {
                    html += refHtml(ref, idx);
                });
            }

            html += `
    <div class="footer">
        <p>Report generated by <a href="https://github.com/idramalab/hallucinator">Hallucinated Reference Detector</a></p>
    </div>
</body>
</html>`;

            return html;
        }

        function generateTxtReport(data) {
            const notFound = data.results.filter(r => r.status === 'not_found');
            const mismatched = data.results.filter(r => r.status === 'author_mismatch');
            const verified = data.results.filter(r => r.status === 'verified');
            const retracted = data.results.filter(r => r.retraction_info && r.retraction_info.retracted);
            const timestamp = new Date().toLocaleString();

            function refTxt(ref, idx) {
                let entry = `\n${idx + 1}. ${ref.title}`;
                if (ref.raw_citation) entry += `\n   Full citation: ${ref.raw_citation}`;
                if (ref.filename) entry += `\n   File: ${ref.filename}`;
                if ((ref.ref_authors || []).length > 0) entry += `\n   Extracted authors: ${ref.ref_authors.join(', ')}`;
                if (ref.source) {
                    entry += `\n   Source: ${ref.source}`;
                    if (ref.paper_url) entry += ` (${ref.paper_url})`;
                }
                if (ref.doi_info && ref.doi_info.doi) entry += `\n   DOI: https://doi.org/${ref.doi_info.doi}`;
                if (ref.arxiv_info && ref.arxiv_info.arxiv_id) entry += `\n   arXiv: https://arxiv.org/abs/${ref.arxiv_info.arxiv_id}`;
                if (ref.retraction_info && ref.retraction_info.retracted) entry += `\n   ‚ö† RETRACTED: ${ref.retraction_info.reason || 'No reason given'}`;
                if ((ref.failed_dbs || []).length > 0) entry += `\n   Databases failed/timed out: ${ref.failed_dbs.join(', ')}`;
                if (ref.status === 'author_mismatch') {
                    entry += `\n   Authors in PDF: ${(ref.ref_authors || []).join(', ')}`;
                    entry += `\n   Authors in ${ref.source}: ${(ref.found_authors || []).join(', ')}`;
                }
                return entry + '\n';
            }

            let txt = `REFERENCE ANALYSIS REPORT
${'='.repeat(50)}
File: ${uploadedFilename}
Generated: ${timestamp}

SUMMARY
${'‚îÄ'.repeat(50)}
Analyzed:          ${data.summary.total}
Verified:          ${data.summary.verified}
Author Mismatches: ${data.summary.mismatched}
Not Found:         ${data.summary.not_found}
Skipped:           ${data.summary.skipped}
`;

            if (notFound.length > 0) {
                txt += `\nNOT FOUND (${notFound.length})\n${'‚îÄ'.repeat(50)}`;
                notFound.forEach((ref, idx) => { txt += refTxt(ref, idx); });
            }

            if (mismatched.length > 0) {
                txt += `\nAUTHOR MISMATCHES (${mismatched.length})\n${'‚îÄ'.repeat(50)}`;
                mismatched.forEach((ref, idx) => { txt += refTxt(ref, idx); });
            }

            const retractedVerified = retracted.filter(r => r.status === 'verified');
            if (retractedVerified.length > 0) {
                txt += `\nRETRACTED PAPERS (${retractedVerified.length})\n${'‚îÄ'.repeat(50)}`;
                retractedVerified.forEach((ref, idx) => { txt += refTxt(ref, idx); });
            }

            txt += `\nVERIFIED REFERENCES (${verified.length})\n${'‚îÄ'.repeat(50)}`;
            if (verified.length === 0) {
                txt += '\nNo references were verified.\n';
            } else {
                verified.filter(r => !(r.retraction_info && r.retraction_info.retracted)).forEach((ref, idx) => {
                    txt += refTxt(ref, idx);
                });
            }

            txt += `\n${'‚îÄ'.repeat(50)}
Report generated by Hallucinated Reference Detector
https://github.com/idramalab/hallucinator
`;

            return txt;
        }

        function showDownloadButton(hasProblems) {
            const downloadSection = document.getElementById('downloadReportSection');
            if (downloadSection) {
                // Always show download button ‚Äî reports now include all references
                downloadSection.classList.add('visible');
            }
        }

        function renderSingleFileResults(data) {
            // Store data for report download
            currentReportData = data;

            // Show download button if there are problems
            const hasProblems = data.summary.not_found > 0 || data.summary.mismatched > 0;
            showDownloadButton(hasProblems);

            // Update summary
            document.getElementById('totalCount').textContent = data.summary.total;
            document.getElementById('verifiedCount').textContent = data.summary.verified;
            document.getElementById('mismatchCount').textContent = data.summary.mismatched;
            document.getElementById('notfoundCount').textContent = data.summary.not_found;
            document.getElementById('skippedCount').textContent = data.summary.skipped;

            // Update skipped details
            const skippedDetails = document.getElementById('skippedDetails');
            const detailParts = [];
            if (data.summary.skipped > 0) {
                const skipParts = [];
                if (data.summary.skipped_url > 0) skipParts.push(`${data.summary.skipped_url} non-academic URLs`);
                if (data.summary.skipped_short_title > 0) skipParts.push(`${data.summary.skipped_short_title} short titles`);
                detailParts.push(`Skipped: ${skipParts.join(', ')}`);
            }
            if (data.summary.title_only > 0) {
                detailParts.push(`Title-only (no authors extracted): ${data.summary.title_only}`);
            }
            skippedDetails.textContent = detailParts.join(' | ');

            // Update DOI issues stat
            const doisFound = data.results.filter(r => r.doi_info).length;
            const doisValid = data.results.filter(r => r.doi_info && r.doi_info.status === 'verified').length;
            const doisInvalid = data.results.filter(r => r.doi_info && r.doi_info.status === 'invalid').length;
            const doisMismatch = data.results.filter(r => r.doi_info && (r.doi_info.status === 'title_mismatch' || r.doi_info.status === 'author_mismatch')).length;
            const doiIssuesTotal = doisInvalid + doisMismatch;

            const doiIssueStat = document.getElementById('doiIssueStat');
            const doiIssueCount = document.getElementById('doiIssueCount');
            if (doiIssuesTotal > 0) {
                doiIssueCount.textContent = doiIssuesTotal;
                doiIssueStat.style.display = '';
            } else {
                doiIssueStat.style.display = 'none';
            }

            // Update arXiv issues stat
            const arxivsFound = data.results.filter(r => r.arxiv_info).length;
            const arxivsValid = data.results.filter(r => r.arxiv_info && r.arxiv_info.status === 'verified').length;
            const arxivsInvalid = data.results.filter(r => r.arxiv_info && r.arxiv_info.status === 'invalid').length;
            const arxivsMismatch = data.results.filter(r => r.arxiv_info && (r.arxiv_info.status === 'title_mismatch' || r.arxiv_info.status === 'author_mismatch')).length;
            const arxivIssuesTotal = arxivsInvalid + arxivsMismatch;

            const arxivIssueStat = document.getElementById('arxivIssueStat');
            const arxivIssueCount = document.getElementById('arxivIssueCount');
            if (arxivIssuesTotal > 0) {
                arxivIssueCount.textContent = arxivIssuesTotal;
                arxivIssueStat.style.display = '';
            } else {
                arxivIssueStat.style.display = 'none';
            }

            // Update retracted papers stat
            const retractedPapers = data.results.filter(r => r.retraction_info && r.retraction_info.retracted);
            const retractedStat = document.getElementById('retractedStat');
            const retractedCountEl = document.getElementById('retractedCount');
            if (retractedPapers.length > 0) {
                retractedCountEl.textContent = retractedPapers.length;
                retractedStat.style.display = '';
            } else {
                retractedStat.style.display = 'none';
            }

            // Show timeout warning separately if there were timeouts
            let timeoutWarning = document.getElementById('timeoutWarning');
            if (!timeoutWarning) {
                timeoutWarning = document.createElement('div');
                timeoutWarning.id = 'timeoutWarning';
                timeoutWarning.style.cssText = 'margin-top: 0.75rem; padding: 0.5rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;';
                skippedDetails.parentNode.insertBefore(timeoutWarning, skippedDetails.nextSibling);
            }
            if (data.summary.total_timeouts > 0) {
                timeoutWarning.innerHTML = `‚ö†Ô∏è DB timeouts: ${data.summary.total_timeouts} (retried ${data.summary.retried_count}, ${data.summary.retry_successes} recovered)`;
                timeoutWarning.style.display = 'block';
            } else {
                timeoutWarning.style.display = 'none';
            }

            // Update problematic percentage - count unique problematic references (no double-counting)
            // A reference is problematic if it has ANY issue (not found, mismatch, DOI issue, arXiv issue, or retracted)
            const problematicPercent = document.getElementById('problematicPercent');
            const problematicRefs = data.results.filter(r =>
                r.status === 'not_found' ||
                r.status === 'author_mismatch' ||
                (r.doi_info && r.doi_info.status !== 'verified') ||
                (r.arxiv_info && r.arxiv_info.status !== 'verified') ||
                (r.retraction_info && r.retraction_info.retracted)
            ).length;
            const problematic = problematicRefs;
            if (data.summary.total > 0) {
                const percent = ((problematic / data.summary.total) * 100).toFixed(1);
                if (problematic === 0) {
                    problematicPercent.textContent = 'All references verified!';
                    problematicPercent.className = 'problematic-percent clean';
                } else {
                    problematicPercent.textContent = `${percent}% of references are problematic (${problematic} of ${data.summary.total})`;
                    problematicPercent.className = 'problematic-percent';
                }
            } else {
                problematicPercent.textContent = '';
            }

            // Show standard summary and hallucinations sections
            document.querySelector('.summary').style.display = 'block';
            document.getElementById('hallucinations').style.display = 'block';

            // Render all results
            const list = document.getElementById('hallucinationList');
            list.innerHTML = '';

            // Remove ALL existing verified sections from previous analyses
            const mainContainer = document.getElementById('hallucinations').parentNode;
            mainContainer.querySelectorAll('.verified-section').forEach(section => section.remove());

            const hallucinations = data.results.filter(r => r.status !== 'verified');
            const verified = data.results.filter(r => r.status === 'verified');

            if (hallucinations.length === 0) {
                list.innerHTML = '<div class="no-hallucinations">All references verified!</div>';
            } else {
                hallucinations.forEach(ref => {
                    list.appendChild(renderHallucination(ref));
                });
                updateFindInPdfButtons();
            }

            // Render DOI issues section
            const doiIssues = data.results.filter(r => r.doi_info && r.doi_info.status !== 'verified');
            const doiIssuesSection = document.getElementById('doiIssuesSection');
            const doiIssuesList = document.getElementById('doiIssuesList');

            if (doiIssues.length > 0) {
                doiIssuesSection.style.display = 'block';
                doiIssuesList.innerHTML = '';

                doiIssues.forEach(ref => {
                    const div = document.createElement('div');
                    div.className = 'reference doi-issue-reference';

                    const doiInfo = ref.doi_info;
                    let issueType = '';
                    let issueDetail = '';

                    if (doiInfo.status === 'invalid') {
                        issueType = 'DOI does not resolve';
                        issueDetail = doiInfo.message || 'Invalid or non-existent DOI';
                    } else if (doiInfo.status === 'title_mismatch') {
                        issueType = 'DOI points to different paper';
                        issueDetail = `Resolves to: "${escapeHtml(doiInfo.doi_title || 'Unknown')}"`;
                    } else if (doiInfo.status === 'author_mismatch') {
                        issueType = 'DOI authors do not match';
                        issueDetail = 'Title matches but authors differ';
                    }

                    const dbStatus = ref.status === 'verified'
                        ? `<span style="color: #16a34a;">‚úì Found in ${escapeHtml(ref.source)}</span>`
                        : ref.status === 'not_found'
                            ? `<span style="color: #dc2626;">‚úó Not found in databases</span>`
                            : `<span style="color: #ca8a04;">‚ö† Author mismatch in ${escapeHtml(ref.source)}</span>`;

                    div.innerHTML = `
                        <div class="reference-title">${escapeHtml(ref.title)}</div>
                        <div class="doi-issue" style="margin-top: 0.5rem;">
                            <strong>DOI:</strong> <a href="https://doi.org/${escapeHtml(doiInfo.doi)}" target="_blank">${escapeHtml(doiInfo.doi)}</a><br>
                            <span style="color: #dc2626;">‚ùå ${issueType}</span><br>
                            <span style="color: var(--text-secondary);">${issueDetail}</span>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                            Database status: ${dbStatus}
                        </div>
                        <div class="reference-actions">
                            <a href="${createScholarLink(ref.title)}" target="_blank" class="scholar-link">
                                Search on Google Scholar &rarr;
                            </a>
                            <button class="mark-safe-btn" onclick="markDoiIssueSafe(this, '${escapeHtml(ref.title).replace(/'/g, "\\'")}')">
                                ‚úì Mark as Safe
                            </button>
                        </div>
                    `;

                    doiIssuesList.appendChild(div);
                });
            } else {
                doiIssuesSection.style.display = 'none';
            }

            // Render arXiv issues section
            const arxivIssues = data.results.filter(r => r.arxiv_info && r.arxiv_info.status !== 'verified');
            const arxivIssuesSection = document.getElementById('arxivIssuesSection');
            const arxivIssuesList = document.getElementById('arxivIssuesList');

            if (arxivIssues.length > 0) {
                arxivIssuesSection.style.display = 'block';
                arxivIssuesList.innerHTML = '';

                arxivIssues.forEach(ref => {
                    const div = document.createElement('div');
                    div.className = 'reference arxiv-issue-reference';

                    const arxivInfo = ref.arxiv_info;
                    let issueType = '';
                    let issueDetail = '';

                    if (arxivInfo.status === 'invalid') {
                        issueType = 'arXiv ID does not resolve';
                        issueDetail = arxivInfo.message || 'Invalid or non-existent arXiv ID';
                    } else if (arxivInfo.status === 'title_mismatch') {
                        issueType = 'arXiv ID points to different paper';
                        issueDetail = `Resolves to: "${escapeHtml(arxivInfo.arxiv_title || 'Unknown')}"`;
                    } else if (arxivInfo.status === 'author_mismatch') {
                        issueType = 'arXiv ID authors do not match';
                        issueDetail = 'Title matches but authors differ';
                    }

                    const dbStatus = ref.status === 'verified'
                        ? `<span style="color: #16a34a;">‚úì Found in ${escapeHtml(ref.source)}</span>`
                        : ref.status === 'not_found'
                            ? `<span style="color: #dc2626;">‚úó Not found in databases</span>`
                            : `<span style="color: #ca8a04;">‚ö† Author mismatch in ${escapeHtml(ref.source)}</span>`;

                    div.innerHTML = `
                        <div class="reference-title">${escapeHtml(ref.title)}</div>
                        <div class="arxiv-issue" style="margin-top: 0.5rem;">
                            <strong>arXiv ID:</strong> <a href="https://arxiv.org/abs/${escapeHtml(arxivInfo.arxiv_id)}" target="_blank">${escapeHtml(arxivInfo.arxiv_id)}</a><br>
                            <span style="color: #dc2626;">‚ùå ${issueType}</span><br>
                            <span style="color: var(--text-secondary);">${issueDetail}</span>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                            Database status: ${dbStatus}
                        </div>
                        <div class="reference-actions">
                            <a href="${createScholarLink(ref.title)}" target="_blank" class="scholar-link">
                                Search on Google Scholar &rarr;
                            </a>
                            <button class="mark-safe-btn" onclick="markArxivIssueSafe(this, '${escapeHtml(ref.title).replace(/'/g, "\\'")}')">
                                ‚úì Mark as Safe
                            </button>
                        </div>
                    `;

                    arxivIssuesList.appendChild(div);
                });
            } else {
                arxivIssuesSection.style.display = 'none';
            }

            // Render retracted papers section
            const retractedSection = document.getElementById('retractedSection');
            const retractedList = document.getElementById('retractedList');

            if (retractedPapers.length > 0) {
                retractedSection.style.display = 'block';
                retractedList.innerHTML = '';

                retractedPapers.forEach(ref => {
                    const div = document.createElement('div');
                    div.className = 'reference retracted-reference';

                    const retractionInfo = ref.retraction_info;
                    const retractionType = retractionInfo.retraction_type || 'Retraction';
                    const retractionDoi = retractionInfo.retraction_doi;
                    const retractionDate = retractionInfo.retraction_date
                        ? new Date(retractionInfo.retraction_date).toLocaleDateString()
                        : null;

                    // Use DOI from doi_info if available, otherwise from retraction_info (found via title search)
                    const originalDoi = (ref.doi_info && ref.doi_info.doi) || retractionInfo.doi;
                    const doiLink = originalDoi
                        ? `<a href="https://doi.org/${escapeHtml(originalDoi)}" target="_blank">${escapeHtml(originalDoi)}</a>`
                        : 'N/A';

                    const retractionDoiLink = retractionDoi
                        ? `<a href="https://doi.org/${escapeHtml(retractionDoi)}" target="_blank">View ${retractionType} Notice ‚Üó</a>`
                        : '';

                    const dbStatus = ref.status === 'verified'
                        ? `<span style="color: #16a34a;">‚úì Found in ${escapeHtml(ref.source)}</span>`
                        : ref.status === 'not_found'
                            ? `<span style="color: #dc2626;">‚úó Not found in databases</span>`
                            : `<span style="color: #ca8a04;">‚ö† Author mismatch in ${escapeHtml(ref.source)}</span>`;

                    div.innerHTML = `
                        <div class="reference-title" style="color: #b91c1c;">${escapeHtml(ref.title)}</div>
                        <div class="retraction-info" style="margin-top: 0.5rem; padding: 0.75rem; background: #fef2f2; border: 1px solid #fecaca; border-radius: 0.375rem;">
                            <span style="color: #b91c1c; font-weight: 600;">‚ö†Ô∏è ${retractionType}</span>
                            ${retractionDate ? `<span style="color: #991b1b; margin-left: 0.5rem;">(${retractionDate})</span>` : ''}
                            <br>
                            <strong>Original DOI:</strong> ${doiLink}<br>
                            ${retractionDoiLink ? `<div style="margin-top: 0.25rem;">${retractionDoiLink}</div>` : ''}
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                            Database status: ${dbStatus}
                        </div>
                        <div class="reference-actions">
                            <a href="${createScholarLink(ref.title)}" target="_blank" class="scholar-link">
                                Search on Google Scholar &rarr;
                            </a>
                        </div>
                    `;

                    retractedList.appendChild(div);
                });
            } else {
                retractedSection.style.display = 'none';
            }

            // Show verified references in collapsible section (after arXiv issues)
            // First check if a verified section already exists (from streaming)
            let verifiedSection = arxivIssuesSection.parentNode.querySelector('.verified-section');
            if (verified.length > 0) {
                if (!verifiedSection) {
                    verifiedSection = document.createElement('div');
                    verifiedSection.className = 'verified-section';
                    verifiedSection.innerHTML = `
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (0)</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list"></div>
                    `;
                    // Insert after arXiv issues section in the DOM
                    arxivIssuesSection.parentNode.insertBefore(verifiedSection, arxivIssuesSection.nextSibling);
                }
                const verifiedList = verifiedSection.querySelector('.verified-list');
                // Clear existing items and repopulate
                verifiedList.innerHTML = '';
                verified.forEach(ref => {
                    const item = document.createElement('div');
                    item.className = 'verified-item';
                    const sourceLink = ref.paper_url
                        ? `<a href="${escapeHtml(ref.paper_url)}" target="_blank" class="verified-source">${escapeHtml(ref.source || 'Unknown')} ‚Üó</a>`
                        : `<span class="verified-source">${escapeHtml(ref.source || 'Unknown')}</span>`;
                    const doiBadge = ref.doi_info && ref.doi_info.doi
                        ? `<a href="https://doi.org/${escapeHtml(ref.doi_info.doi)}" target="_blank" class="doi-badge" title="DOI: ${escapeHtml(ref.doi_info.doi)}">DOI ‚Üó</a>`
                        : '';
                    item.innerHTML = `
                        <span class="verified-title">${escapeHtml(ref.title)}</span>
                        ${sourceLink}
                        ${doiBadge}
                    `;
                    verifiedList.appendChild(item);
                });
                // Update the count in the header
                const countText = verifiedSection.querySelector('.verified-count-text');
                if (countText) {
                    countText.textContent = `Verified References (${verified.length})`;
                }
            } else if (verifiedSection) {
                // No verified refs but section exists from streaming - remove it
                verifiedSection.remove();
            }
        }

        function renderMultiFileResults(data) {
            // Store data for report download (combine all files' results)
            const allResults = [];
            data.files.forEach(file => {
                if (file.success && file.results) {
                    file.results.forEach(r => {
                        allResults.push({ ...r, filename: file.filename });
                    });
                }
            });
            currentReportData = {
                summary: data.summary,
                results: allResults,
                files: data.files,
                isMultiFile: true
            };

            // Show download button if there are problems
            const hasProblems = data.summary.not_found > 0 || data.summary.mismatched > 0;
            showDownloadButton(hasProblems);

            // Hide standard single-file sections
            document.querySelector('.summary').style.display = 'none';
            document.getElementById('hallucinations').style.display = 'none';

            // Remove ALL existing verified sections from previous analyses
            const mainContainer = document.getElementById('hallucinations').parentNode;
            mainContainer.querySelectorAll('.verified-section').forEach(section => section.remove());

            const container = document.getElementById('hallucinationList');
            container.innerHTML = '';

            // Add aggregate header
            const header = document.createElement('div');
            header.className = 'multi-file-header';
            // Count unique problematic references across all files (no double-counting)
            // Note: allResults was already populated earlier in this function
            const aggProblematic = allResults.filter(r =>
                r.status === 'not_found' ||
                r.status === 'author_mismatch' ||
                (r.doi_info && r.doi_info.status !== 'verified') ||
                (r.arxiv_info && r.arxiv_info.status !== 'verified') ||
                (r.retraction_info && r.retraction_info.retracted)
            ).length;
            const aggPercent = data.summary.total > 0 ? ((aggProblematic / data.summary.total) * 100).toFixed(1) : 0;
            const aggPercentClass = aggProblematic === 0 ? 'problematic-percent clean' : 'problematic-percent';
            const aggPercentText = aggProblematic === 0
                ? 'All references verified!'
                : `${aggPercent}% of references are problematic (${aggProblematic} of ${data.summary.total})`;

            header.innerHTML = `
                <h2>Archive Results</h2>
                <div class="file-count">${data.file_count} PDF files processed</div>
                <div class="stats" style="margin-top: 1rem;">
                    <div class="stat">
                        <div class="stat-value">${data.summary.total}</div>
                        <div class="stat-label">Total Analyzed</div>
                    </div>
                    <div class="stat stat-verified">
                        <div class="stat-value">${data.summary.verified}</div>
                        <div class="stat-label">Verified</div>
                    </div>
                    <div class="stat stat-mismatch">
                        <div class="stat-value">${data.summary.mismatched}</div>
                        <div class="stat-label">Mismatches</div>
                    </div>
                    <div class="stat stat-notfound">
                        <div class="stat-value">${data.summary.not_found}</div>
                        <div class="stat-label">Not Found</div>
                    </div>
                </div>
                <div class="${aggPercentClass}">${aggPercentText}</div>
                <div class="timeout-warning" style="margin-top: 0.75rem; padding: 0.5rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;">
                        ‚ö†Ô∏è DB timeouts: ${data.summary.total_timeouts || 0} (retried ${data.summary.retried_count || 0}, ${data.summary.retry_successes || 0} recovered)
                    </div>
            `;
            container.appendChild(header);

            // Render each file as collapsible section
            data.files.forEach((file, index) => {
                const section = document.createElement('div');
                section.className = 'file-section';

                const hasIssues = file.success && file.results.some(r => r.status !== 'verified');
                const hasError = !file.success;

                let statusBadge = '';
                if (hasError) {
                    statusBadge = '<span class="file-status-badge file-status-error">Error</span>';
                } else if (hasIssues) {
                    const issueCount = file.results.filter(r => r.status !== 'verified').length;
                    statusBadge = `<span class="file-status-badge file-status-issues">${issueCount} issue${issueCount > 1 ? 's' : ''}</span>`;
                } else {
                    statusBadge = '<span class="file-status-badge file-status-ok">All verified</span>';
                }

                // Auto-expand files with issues or errors
                const autoExpand = hasIssues || hasError;

                section.innerHTML = `
                    <div class="file-header" data-index="${index}">
                        <div class="file-header-left">
                            <span class="file-name">${escapeHtml(file.filename)}</span>
                            ${statusBadge}
                        </div>
                        <span class="file-toggle ${autoExpand ? 'expanded' : ''}">&#9660;</span>
                    </div>
                    <div class="file-content ${autoExpand ? 'visible' : ''}" id="file-content-${index}">
                        ${renderFileContent(file)}
                    </div>
                `;

                // Add click handler for toggle
                section.querySelector('.file-header').addEventListener('click', () => {
                    const content = section.querySelector('.file-content');
                    const toggle = section.querySelector('.file-toggle');
                    content.classList.toggle('visible');
                    toggle.classList.toggle('expanded');
                });

                container.appendChild(section);
            });

            // Update "Find in PDF" button visibility
            updateFindInPdfButtons();

            // Show the hallucinations container (we're using it for multi-file display)
            document.getElementById('hallucinations').style.display = 'block';
            document.getElementById('hallucinations').querySelector('h2').style.display = 'none';
        }

        function renderFileContent(file) {
            if (!file.success) {
                return `<div class="file-error">Error: ${escapeHtml(file.error)}</div>`;
            }

            const hallucinations = file.results.filter(r => r.status !== 'verified');
            // Count unique problematic references (no double-counting)
            const fileProblematic = file.results.filter(r =>
                r.status === 'not_found' ||
                r.status === 'author_mismatch' ||
                (r.doi_info && r.doi_info.status !== 'verified') ||
                (r.arxiv_info && r.arxiv_info.status !== 'verified') ||
                (r.retraction_info && r.retraction_info.retracted)
            ).length;
            const filePercent = file.summary.total > 0 ? ((fileProblematic / file.summary.total) * 100).toFixed(1) : 0;
            const filePercentClass = fileProblematic === 0 ? 'problematic-percent clean' : 'problematic-percent';
            const filePercentText = fileProblematic === 0
                ? 'All references verified!'
                : `${filePercent}% problematic (${fileProblematic} of ${file.summary.total})`;

            let html = `
                <div class="file-summary">
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value">${file.summary.total}</div>
                            <div class="stat-label">Analyzed</div>
                        </div>
                        <div class="stat stat-verified">
                            <div class="stat-value">${file.summary.verified}</div>
                            <div class="stat-label">Verified</div>
                        </div>
                        <div class="stat stat-mismatch">
                            <div class="stat-value">${file.summary.mismatched}</div>
                            <div class="stat-label">Mismatches</div>
                        </div>
                        <div class="stat stat-notfound">
                            <div class="stat-value">${file.summary.not_found}</div>
                            <div class="stat-label">Not Found</div>
                        </div>
                    </div>
                    <div class="${filePercentClass}">${filePercentText}</div>
                    ${file.summary.total_timeouts > 0 ? `
                        <div class="timeout-warning" style="margin-top: 0.5rem; padding: 0.375rem 0.75rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.25rem; color: #92400e; font-size: 0.85rem;">
                            ‚ö†Ô∏è DB timeouts: ${file.summary.total_timeouts} (retried ${file.summary.retried_count}, ${file.summary.retry_successes} recovered)
                        </div>
                    ` : ''}
                </div>
            `;

            if (hallucinations.length === 0) {
                html += '<div class="no-hallucinations">All references verified!</div>';
            } else {
                hallucinations.forEach(ref => {
                    const div = document.createElement('div');
                    div.appendChild(renderHallucination(ref));
                    html += div.innerHTML;
                });
            }

            // Add DOI issues section
            const doiIssues = file.results.filter(r => r.doi_info && r.doi_info.status !== 'verified');
            if (doiIssues.length > 0) {
                html += `
                    <div class="doi-issues-section" style="margin-top: 1.5rem;">
                        <h3 style="color: #9333ea; margin-bottom: 0.75rem;">DOI Issues (${doiIssues.length})</h3>
                        ${doiIssues.map(ref => {
                            const doiInfo = ref.doi_info;
                            let issueType = '';
                            let issueDetail = '';
                            if (doiInfo.status === 'invalid') {
                                issueType = 'DOI does not resolve';
                                issueDetail = doiInfo.message || 'Invalid or non-existent DOI';
                            } else if (doiInfo.status === 'title_mismatch') {
                                issueType = 'DOI points to different paper';
                                issueDetail = 'Resolves to: "' + escapeHtml(doiInfo.doi_title || 'Unknown') + '"';
                            } else if (doiInfo.status === 'author_mismatch') {
                                issueType = 'DOI authors do not match';
                                issueDetail = 'Title matches but authors differ';
                            }
                            const dbStatus = ref.status === 'verified'
                                ? '<span style="color: #16a34a;">‚úì Found in ' + escapeHtml(ref.source) + '</span>'
                                : ref.status === 'not_found'
                                    ? '<span style="color: #dc2626;">‚úó Not found in databases</span>'
                                    : '<span style="color: #ca8a04;">‚ö† Author mismatch in ' + escapeHtml(ref.source) + '</span>';
                            return `
                                <div class="reference doi-issue-reference" style="margin-bottom: 1rem; padding: 1rem; border: 1px solid #9333ea33; border-radius: 0.5rem; background: var(--card-background);">
                                    <div class="reference-title" style="font-weight: 600; margin-bottom: 0.5rem;">${escapeHtml(ref.title)}</div>
                                    <div class="doi-issue" style="margin-top: 0.5rem;">
                                        <strong>DOI:</strong> <a href="https://doi.org/${escapeHtml(doiInfo.doi)}" target="_blank">${escapeHtml(doiInfo.doi)}</a><br>
                                        <span style="color: #dc2626;">‚ùå ${issueType}</span><br>
                                        <span style="color: var(--text-secondary);">${issueDetail}</span>
                                    </div>
                                    <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                                        Database status: ${dbStatus}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Add retracted papers section
            const retractedPapers = file.results.filter(r => r.retraction_info && r.retraction_info.retracted);
            if (retractedPapers.length > 0) {
                html += `
                    <div class="retracted-section" style="margin-top: 1.5rem;">
                        <h3 style="color: #b91c1c; margin-bottom: 0.75rem;">‚ö†Ô∏è Retracted Papers (${retractedPapers.length})</h3>
                        ${retractedPapers.map(ref => {
                            const retractionInfo = ref.retraction_info;
                            const retractionType = retractionInfo.retraction_type || 'Retraction';
                            const retractionDoi = retractionInfo.retraction_doi;
                            const retractionDate = retractionInfo.retraction_date
                                ? new Date(retractionInfo.retraction_date).toLocaleDateString()
                                : null;
                            // Use DOI from doi_info if available, otherwise from retraction_info (found via title search)
                            const originalDoi = (ref.doi_info && ref.doi_info.doi) || retractionInfo.doi;
                            const doiLink = originalDoi
                                ? '<a href="https://doi.org/' + escapeHtml(originalDoi) + '" target="_blank">' + escapeHtml(originalDoi) + '</a>'
                                : 'N/A';
                            const retractionDoiLink = retractionDoi
                                ? '<a href="https://doi.org/' + escapeHtml(retractionDoi) + '" target="_blank">View ' + retractionType + ' Notice ‚Üó</a>'
                                : '';
                            const dbStatus = ref.status === 'verified'
                                ? '<span style="color: #16a34a;">‚úì Found in ' + escapeHtml(ref.source) + '</span>'
                                : ref.status === 'not_found'
                                    ? '<span style="color: #dc2626;">‚úó Not found in databases</span>'
                                    : '<span style="color: #ca8a04;">‚ö† Author mismatch in ' + escapeHtml(ref.source) + '</span>';
                            return `
                                <div class="reference retracted-reference" style="margin-bottom: 1rem; padding: 1rem; border: 1px solid #fecaca; border-radius: 0.5rem; background: #fef2f2;">
                                    <div class="reference-title" style="font-weight: 600; margin-bottom: 0.5rem; color: #b91c1c;">${escapeHtml(ref.title)}</div>
                                    <div class="retraction-info" style="margin-top: 0.5rem;">
                                        <span style="color: #b91c1c; font-weight: 600;">‚ö†Ô∏è ${retractionType}</span>
                                        ${retractionDate ? '<span style="color: #991b1b; margin-left: 0.5rem;">(' + retractionDate + ')</span>' : ''}
                                        <br>
                                        <strong>Original DOI:</strong> ${doiLink}<br>
                                        ${retractionDoiLink ? '<div style="margin-top: 0.25rem;">' + retractionDoiLink + '</div>' : ''}
                                    </div>
                                    <div style="margin-top: 0.5rem; font-size: 0.9rem;">
                                        Database status: ${dbStatus}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Add verified references section (after DOI issues)
            const verified = file.results.filter(r => r.status === 'verified');
            if (verified.length > 0) {
                html += `
                    <div class="verified-section">
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span class="verified-count-text">Verified References (${verified.length})</span>
                            <span class="verified-toggle">‚ñº</span>
                        </div>
                        <div class="verified-list">
                            ${verified.map(ref => `
                                <div class="verified-item">
                                    <span class="verified-title">${escapeHtml(ref.title)}</span>
                                    ${ref.paper_url
                                        ? `<a href="${escapeHtml(ref.paper_url)}" target="_blank" class="verified-source">${escapeHtml(ref.source || 'Unknown')} ‚Üó</a>`
                                        : `<span class="verified-source">${escapeHtml(ref.source || 'Unknown')}</span>`
                                    }
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderCancelledResults(serverData) {
            progressSection.classList.remove('visible');

            // Use server-provided partial results if available, fall back to liveResults
            const hasServerData = serverData && serverData.results && serverData.results.length > 0;
            const resultData = hasServerData ? serverData.results : liveResults;
            const checked = resultData.length;

            if (checked === 0) {
                errorMessage.textContent = 'Analysis cancelled.';
                errorMessage.classList.add('visible');
                return;
            }

            const summary = hasServerData ? serverData.summary : {
                total: checked,
                verified: liveResults.filter(r => r.status === 'verified').length,
                not_found: liveResults.filter(r => r.status === 'not_found').length,
                mismatched: liveResults.filter(r => r.status === 'author_mismatch').length,
                skipped: 0,
                skipped_url: 0,
                skipped_short_title: 0,
                title_only: 0,
            };

            document.getElementById('hallucinations').querySelector('h2').style.display = 'block';

            renderSingleFileResults({
                summary: summary,
                results: resultData,
            });

            // Show a warning banner that results are partial
            const resultsSection = document.getElementById('hallucinations');
            const cancelBanner = document.createElement('div');
            cancelBanner.style.cssText = 'margin-bottom: 1rem; padding: 0.5rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;';
            cancelBanner.textContent = `Analysis cancelled. Showing partial results: ${checked} of ${totalRefs || '?'} references checked.`;
            resultsSection.insertBefore(cancelBanner, resultsSection.children[1]);

            results.classList.add('visible');
        }

        function resetProgressUI() {
            liveResults = [];
            totalRefs = 0;
            isArchive = false;
            archiveFileCount = 0;
            currentFileIndex = 0;
            currentFilename = '';
            progressBar.style.width = '0%';
            progressStatus.textContent = 'Extracting references...';
            progressCurrent.textContent = '';
            progressResults.innerHTML = '';
            progressHeaderText.textContent = 'Analyzing references...';
        }

        function addProgressResult(data) {
            const item = document.createElement('div');
            item.className = 'progress-result-item';

            let statusClass = '';
            let statusText = '';
            if (data.status === 'verified') {
                statusClass = 'progress-result-verified';
                statusText = `VERIFIED (${data.source})`;
            } else if (data.status === 'author_mismatch') {
                statusClass = 'progress-result-mismatch';
                statusText = `MISMATCH (${data.source})`;
            } else {
                statusClass = 'progress-result-notfound';
                statusText = 'NOT FOUND';
            }

            const shortTitle = data.title.length > 50 ? data.title.substring(0, 50) + '...' : data.title;
            item.innerHTML = `<span class="${statusClass}">[${data.index + 1}/${data.total}]</span> ${escapeHtml(shortTitle)} - <span class="${statusClass}">${statusText}</span>`;

            progressResults.appendChild(item);
            progressResults.scrollTop = progressResults.scrollHeight;
        }

        cancelBtn.addEventListener('click', () => {
            if (currentAbortController && confirm('Are you sure you want to cancel the current analysis?')) {
                currentAbortController.abort();
                currentAbortController = null;
            }
        });

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(form);
            const fileInput = document.getElementById('pdfFile');
            const file = fileInput.files[0];

            if (!file) {
                errorMessage.textContent = 'Please select a file';
                errorMessage.classList.add('visible');
                return;
            }

            // Store the uploaded filename for reports
            uploadedFilename = file.name;

            // Save API keys to localStorage
            const openalexKeyValue = openalexKeyInput.value.trim();
            if (openalexKeyValue) {
                localStorage.setItem('openalexKey', openalexKeyValue);
            } else {
                localStorage.removeItem('openalexKey');
            }
            const s2KeyValue = s2ApiKeyInput.value.trim();
            if (s2KeyValue) {
                localStorage.setItem('s2ApiKey', s2KeyValue);
            } else {
                localStorage.removeItem('s2ApiKey');
            }
            // Save checkbox state
            if (checkOpenalexAuthorsInput.checked) {
                localStorage.setItem('checkOpenalexAuthors', 'true');
            } else {
                localStorage.removeItem('checkOpenalexAuthors');
            }

            // Collect disabled databases and save to localStorage + FormData
            const disabledDbs = [];
            document.querySelectorAll('[data-db]').forEach(cb => {
                if (!cb.checked) {
                    disabledDbs.push(cb.getAttribute('data-db'));
                }
            });
            if (disabledDbs.length > 0) {
                localStorage.setItem('disabledDbs', JSON.stringify(disabledDbs));
                formData.append('disabled_dbs', JSON.stringify(disabledDbs));
            } else {
                localStorage.removeItem('disabledDbs');
            }

            // Reset UI
            submitBtn.disabled = true;
            resetProgressUI();
            progressSection.classList.add('visible');
            errorMessage.classList.remove('visible');
            results.classList.remove('visible');

            // Use SSE for all uploads (PDFs and archives)
            currentAbortController = new AbortController();
            try {
                const response = await fetch('/analyze/stream', {
                    method: 'POST',
                    body: formData,
                    signal: currentAbortController.signal,
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Analysis failed');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                // Process SSE events - split by double newline
                function processEvent(eventText) {
                    const lines = eventText.trim().split('\n');
                    let eventType = null;
                    let eventData = null;

                    for (const line of lines) {
                        if (line.startsWith('event:')) {
                            eventType = line.substring(6).trim();
                        } else if (line.startsWith('data:')) {
                            try {
                                eventData = JSON.parse(line.substring(5).trim());
                            } catch (e) {
                                console.error('Failed to parse SSE data:', line);
                            }
                        }
                    }

                    if (!eventType || !eventData) return;

                    console.log('SSE event:', eventType, eventData);
                    if (eventData && eventData.summary) {
                        console.log('Summary data:', eventData.summary);
                        console.log('total_timeouts:', eventData.summary.total_timeouts);
                    }

                    if (eventType === 'archive_start') {
                        isArchive = true;
                        archiveFileCount = eventData.file_count;
                        progressHeaderText.textContent = `Processing ${archiveFileCount} files...`;
                        progressStatus.textContent = `Archive with ${archiveFileCount} PDFs`;
                    } else if (eventType === 'file_start') {
                        currentFileIndex = eventData.file_index;
                        currentFilename = eventData.filename;
                        liveResults = []; // Reset for new file
                        totalRefs = 0;
                        if (isArchive) {
                            progressHeaderText.textContent = `File ${currentFileIndex + 1}/${archiveFileCount}: ${currentFilename}`;
                            // Add file separator in results
                            const separator = document.createElement('div');
                            separator.className = 'progress-result-item';
                            separator.innerHTML = `<strong style="color: #2563eb;">--- ${escapeHtml(currentFilename)} ---</strong>`;
                            progressResults.appendChild(separator);
                            progressResults.scrollTop = progressResults.scrollHeight;
                        }
                        progressStatus.textContent = 'Extracting references...';
                    } else if (eventType === 'file_complete') {
                        if (isArchive) {
                            const fc = eventData;
                            if (fc.success) {
                                progressStatus.textContent = `File ${currentFileIndex + 1}/${archiveFileCount} complete: ${fc.summary.verified} verified, ${fc.summary.not_found} not found`;
                            } else {
                                progressStatus.textContent = `File ${currentFileIndex + 1}/${archiveFileCount} failed: ${fc.error}`;
                            }
                            // Update overall progress bar based on files completed
                            const filePct = ((currentFileIndex + 1) / archiveFileCount) * 100;
                            progressBar.style.width = filePct + '%';
                        }
                    } else if (eventType === 'extraction_complete') {
                        totalRefs = eventData.total_refs;
                        const prefix = isArchive ? `[${currentFilename}] ` : '';
                        progressStatus.textContent = `${prefix}Found ${totalRefs} references to check`;
                        if (!isArchive) {
                            progressHeaderText.textContent = `Checking ${totalRefs} references...`;
                        }
                    } else if (eventType === 'retry_pass') {
                        progressStatus.textContent = `Retrying ${eventData.count} references that had timeouts...`;
                        progressHeaderText.textContent = `Retry pass...`;
                    } else if (eventType === 'checking') {
                        const shortTitle = eventData.title.length > 60
                            ? eventData.title.substring(0, 60) + '...'
                            : eventData.title;
                        progressCurrent.textContent = `[${eventData.index + 1}/${eventData.total}] Checking: "${shortTitle}"`;
                        // For single PDF, update progress bar based on refs; for archive, keep file-based progress
                        if (!isArchive) {
                            const pct = ((eventData.index) / eventData.total) * 100;
                            progressBar.style.width = pct + '%';
                        }
                    } else if (eventType === 'result') {
                        liveResults.push(eventData);
                        addProgressResult(eventData);

                        // Update status with running totals
                        const verified = liveResults.filter(r => r.status === 'verified').length;
                        const notFound = liveResults.filter(r => r.status === 'not_found').length;
                        const mismatch = liveResults.filter(r => r.status === 'author_mismatch').length;

                        if (!isArchive) {
                            const pct = ((eventData.index + 1) / eventData.total) * 100;
                            progressBar.style.width = pct + '%';
                            progressStatus.textContent = `Checked ${eventData.index + 1}/${eventData.total}: ${verified} verified, ${notFound} not found, ${mismatch} mismatched`;
                        } else {
                            progressStatus.textContent = `[${currentFilename}] ${eventData.index + 1}/${eventData.total}: ${verified} verified, ${notFound} not found, ${mismatch} mismatched`;
                        }
                    } else if (eventType === 'warning') {
                        // Display warning about failed databases
                        const warningItem = document.createElement('div');
                        warningItem.className = 'progress-result-item';
                        warningItem.innerHTML = `
                            <span style="color: #d97706;">‚ö†Ô∏è [${eventData.index + 1}/${eventData.total}]</span>
                            <span style="color: #92400e;">${escapeHtml(eventData.message)}</span>
                        `;
                        progressResults.appendChild(warningItem);
                        progressResults.scrollTop = progressResults.scrollHeight;
                    } else if (eventType === 'complete') {
                        // Analysis complete - render full results
                        progressSection.classList.remove('visible');

                        // Reset the hallucinations header visibility
                        document.getElementById('hallucinations').querySelector('h2').style.display = 'block';

                        // Check if this is a multi-file result
                        if (eventData.files && eventData.file_count > 1) {
                            renderMultiFileResults(eventData);
                        } else {
                            renderSingleFileResults({
                                summary: eventData.summary,
                                results: eventData.results,
                            });
                        }

                        results.classList.add('visible');
                    } else if (eventType === 'cancelled') {
                        renderCancelledResults(eventData);
                        return;
                    } else if (eventType === 'error') {
                        throw new Error(eventData.message || 'Analysis failed');
                    }
                }

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // SSE events are separated by double newlines
                    const events = buffer.split('\n\n');
                    buffer = events.pop(); // Keep incomplete event in buffer

                    for (const eventText of events) {
                        if (eventText.trim()) {
                            processEvent(eventText);
                        }
                    }
                }

            } catch (err) {
                if (err.name === 'AbortError') {
                    renderCancelledResults();
                } else {
                    progressSection.classList.remove('visible');
                    errorMessage.textContent = err.message;
                    errorMessage.classList.add('visible');
                }
            } finally {
                currentAbortController = null;
                submitBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
