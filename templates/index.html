<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hallucinated Reference Checker</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }
        .subtitle {
            color: #666;
            margin-bottom: 2rem;
        }
        .upload-form {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .label-hint {
            font-weight: normal;
            color: #666;
            font-size: 0.9em;
        }
        input[type="file"],
        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        input[type="file"] {
            background: #fafafa;
        }
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #1d4ed8;
        }
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .progress-section {
            display: none;
            margin-top: 1rem;
        }
        .progress-section.visible {
            display: block;
        }
        .progress-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            color: #333;
        }
        .spinner-icon {
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .progress-bar-container {
            background: #e5e7eb;
            border-radius: 4px;
            height: 8px;
            margin-bottom: 0.75rem;
            overflow: hidden;
        }
        .progress-bar {
            background: #2563eb;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-status {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }
        .progress-current {
            font-size: 0.85rem;
            color: #888;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .progress-results {
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85rem;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 0.5rem;
            background: #fafafa;
        }
        .progress-result-item {
            padding: 0.25rem 0;
            border-bottom: 1px solid #eee;
        }
        .progress-result-item:last-child {
            border-bottom: none;
        }
        .progress-result-verified {
            color: #16a34a;
        }
        .progress-result-mismatch {
            color: #ca8a04;
        }
        .progress-result-notfound {
            color: #dc2626;
        }
        .results {
            display: none;
        }
        .results.visible {
            display: block;
        }
        .summary {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }
        .summary h2 {
            margin-top: 0;
            margin-bottom: 1rem;
        }
        .stats {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }
        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }
        .stat-verified .stat-value { color: #16a34a; }
        .stat-mismatch .stat-value { color: #ca8a04; }
        .stat-notfound .stat-value { color: #dc2626; }
        .stat-skipped .stat-value { color: #6b7280; }
        .skipped-details {
            color: #6b7280;
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }
        .problematic-percent {
            color: #dc2626;
            font-size: 0.95rem;
            font-weight: 500;
            margin-top: 0.75rem;
        }
        .problematic-percent.clean {
            color: #16a34a;
        }
        .hallucinations {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .hallucinations h2 {
            margin: 0;
            padding: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .reference {
            padding: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .reference:last-child {
            border-bottom: none;
        }
        .reference-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            word-break: break-word;
        }
        .reference-status {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }
        .status-not-found {
            background: #fef2f2;
            color: #dc2626;
        }
        .status-mismatch {
            background: #fefce8;
            color: #ca8a04;
        }
        .author-comparison {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }
        .author-comparison h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: #666;
        }
        .author-list {
            margin: 0;
            padding-left: 1.25rem;
        }
        .scholar-link {
            display: inline-block;
            color: #2563eb;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .scholar-link:hover {
            text-decoration: underline;
        }
        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: none;
        }
        .error-message.visible {
            display: block;
        }
        .no-hallucinations {
            padding: 2rem;
            text-align: center;
            color: #16a34a;
        }
        .verified-section {
            border-top: 1px solid #eee;
            margin-top: 1rem;
        }
        .verified-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: #f0fdf4;
            cursor: pointer;
            user-select: none;
            color: #16a34a;
            font-weight: 500;
        }
        .verified-header:hover {
            background: #dcfce7;
        }
        .verified-toggle {
            transition: transform 0.2s;
        }
        .verified-section.expanded .verified-toggle {
            transform: rotate(180deg);
        }
        .verified-list {
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        .verified-section.expanded .verified-list {
            display: block;
        }
        .verified-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border-bottom: 1px solid #eee;
            gap: 1rem;
        }
        .verified-item:last-child {
            border-bottom: none;
        }
        .verified-title {
            flex: 1;
            word-break: break-word;
        }
        .verified-source {
            color: #16a34a;
            font-size: 0.85rem;
            white-space: nowrap;
            text-decoration: none;
        }
        a.verified-source:hover {
            text-decoration: underline;
        }
        /* Multi-file archive styles */
        .file-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .file-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: #f9fafb;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            user-select: none;
        }
        .file-header:hover {
            background: #f3f4f6;
        }
        .file-header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .file-name {
            font-weight: 600;
            word-break: break-word;
        }
        .file-status-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .file-status-ok {
            background: #dcfce7;
            color: #16a34a;
        }
        .file-status-issues {
            background: #fef2f2;
            color: #dc2626;
        }
        .file-status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        .file-toggle {
            font-size: 1.2rem;
            transition: transform 0.2s ease;
            color: #6b7280;
        }
        .file-toggle.expanded {
            transform: rotate(180deg);
        }
        .file-content {
            display: none;
            padding: 1.5rem;
            border-top: 1px solid #eee;
        }
        .file-content.visible {
            display: block;
        }
        .file-error {
            color: #dc2626;
            background: #fef2f2;
            padding: 1rem;
            border-radius: 4px;
        }
        .file-summary {
            margin-bottom: 1rem;
        }
        .file-summary .stats {
            gap: 1.5rem;
        }
        .file-summary .stat-value {
            font-size: 1.5rem;
        }
        .multi-file-header {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }
        .multi-file-header h2 {
            margin: 0 0 0.5rem 0;
        }
        .multi-file-header .file-count {
            color: #666;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .logo {
            width: 100px;
            height: 100px;
            object-fit: contain;
        }
        .header-text h1 {
            margin: 0 0 0.25rem 0;
        }
        .header-text .subtitle {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="/static/logo.png" alt="Logo" class="logo">
        <div class="header-text">
            <h1>Hallucinated Reference Checker</h1>
            <p class="subtitle">Upload a PDF to check for potentially hallucinated or incorrect references</p>
        </div>
    </div>
    <p class="subtitle">Inspired by Madison Akles' <a href="https://madisonakles.github.io/checker.html">in-browser hallucination checker</a> | <a href="https://github.com/gianlucasb/hallucinator">Project GitHub</a></p>

    <div style="margin-bottom: 1rem; padding: 0.75rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;">
        <strong>OpenReview Disabled:</strong> On Nov 27, 2025, bad actors <a href="https://blog.iclr.cc/2025/12/03/iclr-2026-response-to-security-incident/" style="color: #92400e;">exploited an API vulnerability</a> to deanonymize 45% of ICLR 2026 submissions (~10,000 papers), exposing reviewers, authors, and area chairs. The leaked data was used to harass reviewers, offer bribes, and coordinate collusion between authors and reviewers—a direct attack on the integrity of peer review. This happened while the ML community was already dealing with a flood of LLM-generated slop submissions. The OpenReview API is currently unreachable. This incident is exactly why tools like this need to exist.
    </div>

    <div class="upload-form">
        <form id="analyzeForm">
            <div class="form-group">
                <label for="pdfFile">PDF File or Archive (.zip, .tar.gz)</label>
                <input type="file" id="pdfFile" name="pdf" accept=".pdf,.zip,.tar.gz,.tgz" required>
            </div>
            <div class="form-group">
                <label for="openalexKey">
                    OpenAlex API Key
                    <span class="label-hint">(optional, improves coverage)</span>
                </label>
                <input type="text" id="openalexKey" name="openalex_key" placeholder="Enter your OpenAlex API key">
            </div>
            <div class="form-group">
                <label for="s2ApiKey">
                    Semantic Scholar API Key
                    <span class="label-hint">(optional, avoids rate limiting)</span>
                </label>
                <input type="text" id="s2ApiKey" name="s2_api_key" placeholder="Enter your Semantic Scholar API key">
            </div>
            <button type="submit" id="submitBtn">Analyze References</button>
        </form>
        <div class="progress-section" id="progressSection">
            <div class="progress-header">
                <div class="spinner-icon"></div>
                <span id="progressHeaderText">Analyzing references...</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-status" id="progressStatus">Extracting references...</div>
            <div class="progress-current" id="progressCurrent"></div>
            <div class="progress-results" id="progressResults"></div>
        </div>
        <div class="error-message" id="errorMessage"></div>
    </div>

    <div class="results" id="results">
        <div class="summary">
            <h2>Summary</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">Analyzed</div>
                </div>
                <div class="stat stat-verified">
                    <div class="stat-value" id="verifiedCount">0</div>
                    <div class="stat-label">Verified</div>
                </div>
                <div class="stat stat-mismatch">
                    <div class="stat-value" id="mismatchCount">0</div>
                    <div class="stat-label">Author Mismatches</div>
                </div>
                <div class="stat stat-notfound">
                    <div class="stat-value" id="notfoundCount">0</div>
                    <div class="stat-label">Not Found</div>
                </div>
                <div class="stat stat-skipped">
                    <div class="stat-value" id="skippedCount">0</div>
                    <div class="stat-label">Skipped</div>
                </div>
            </div>
            <div class="skipped-details" id="skippedDetails"></div>
            <div class="problematic-percent" id="problematicPercent"></div>
        </div>

        <div class="hallucinations" id="hallucinations">
            <h2>Potential Hallucinations</h2>
            <div id="hallucinationList"></div>
        </div>
    </div>

    <script>
        const form = document.getElementById('analyzeForm');
        const submitBtn = document.getElementById('submitBtn');
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        const progressStatus = document.getElementById('progressStatus');
        const progressCurrent = document.getElementById('progressCurrent');
        const progressResults = document.getElementById('progressResults');
        const progressHeaderText = document.getElementById('progressHeaderText');
        const errorMessage = document.getElementById('errorMessage');
        const results = document.getElementById('results');
        const openalexKeyInput = document.getElementById('openalexKey');
        const s2ApiKeyInput = document.getElementById('s2ApiKey');

        // Load saved API keys from localStorage
        const savedOpenalexKey = localStorage.getItem('openalexKey');
        if (savedOpenalexKey) {
            openalexKeyInput.value = savedOpenalexKey;
        }
        const savedS2Key = localStorage.getItem('s2ApiKey');
        if (savedS2Key) {
            s2ApiKeyInput.value = savedS2Key;
        }

        // Track live results during streaming
        let liveResults = [];
        let totalRefs = 0;
        let isArchive = false;
        let archiveFileCount = 0;
        let currentFileIndex = 0;
        let currentFilename = '';

        function createScholarLink(title) {
            const encoded = encodeURIComponent(title);
            return `https://scholar.google.com/scholar?q=${encoded}`;
        }

        function renderHallucination(ref) {
            const div = document.createElement('div');
            div.className = 'reference';

            let statusClass = ref.error_type === 'not_found' ? 'status-not-found' : 'status-mismatch';
            let statusText = ref.error_type === 'not_found'
                ? 'Not found in any database'
                : `Author mismatch (found on ${ref.source})`;

            let authorHtml = '';
            if (ref.error_type === 'author_mismatch') {
                authorHtml = `
                    <div class="author-comparison">
                        <h4>Authors in PDF:</h4>
                        <ul class="author-list">
                            ${ref.ref_authors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                        </ul>
                        <h4 style="margin-top: 0.75rem;">Authors in ${escapeHtml(ref.source)}:</h4>
                        <ul class="author-list">
                            ${ref.found_authors.map(a => `<li>${escapeHtml(a)}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // Show which databases timed out
            let timeoutHtml = '';
            if (ref.failed_dbs && ref.failed_dbs.length > 0) {
                timeoutHtml = `
                    <div class="timeout-info" style="margin-top: 0.5rem; padding: 0.375rem 0.75rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.25rem; color: #92400e; font-size: 0.85rem;">
                        ⚠️ Timed out: ${ref.failed_dbs.map(db => escapeHtml(db)).join(', ')}
                    </div>
                `;
            }

            div.innerHTML = `
                <div class="reference-title">${escapeHtml(ref.title)}</div>
                <div class="reference-status ${statusClass}">${statusText}</div>
                ${timeoutHtml}
                ${authorHtml}
                <a href="${createScholarLink(ref.title)}" target="_blank" class="scholar-link">
                    Search on Google Scholar &rarr;
                </a>
            `;

            return div;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function renderSingleFileResults(data) {
            // Update summary
            document.getElementById('totalCount').textContent = data.summary.total;
            document.getElementById('verifiedCount').textContent = data.summary.verified;
            document.getElementById('mismatchCount').textContent = data.summary.mismatched;
            document.getElementById('notfoundCount').textContent = data.summary.not_found;
            document.getElementById('skippedCount').textContent = data.summary.skipped;

            // Update skipped details
            const skippedDetails = document.getElementById('skippedDetails');
            const detailParts = [];
            if (data.summary.skipped > 0) {
                const skipParts = [];
                if (data.summary.skipped_url > 0) skipParts.push(`${data.summary.skipped_url} non-academic URLs`);
                if (data.summary.skipped_short_title > 0) skipParts.push(`${data.summary.skipped_short_title} short titles`);
                detailParts.push(`Skipped: ${skipParts.join(', ')}`);
            }
            if (data.summary.title_only > 0) {
                detailParts.push(`Title-only (no authors extracted): ${data.summary.title_only}`);
            }
            skippedDetails.textContent = detailParts.join(' | ');

            // Show timeout warning separately if there were timeouts
            let timeoutWarning = document.getElementById('timeoutWarning');
            if (!timeoutWarning) {
                timeoutWarning = document.createElement('div');
                timeoutWarning.id = 'timeoutWarning';
                timeoutWarning.style.cssText = 'margin-top: 0.75rem; padding: 0.5rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;';
                skippedDetails.parentNode.insertBefore(timeoutWarning, skippedDetails.nextSibling);
            }
            if (data.summary.total_timeouts > 0) {
                timeoutWarning.innerHTML = `⚠️ DB timeouts: ${data.summary.total_timeouts} (retried ${data.summary.retried_count}, ${data.summary.retry_successes} recovered)`;
                timeoutWarning.style.display = 'block';
            } else {
                timeoutWarning.style.display = 'none';
            }

            // Update problematic percentage
            const problematicPercent = document.getElementById('problematicPercent');
            const problematic = data.summary.not_found + data.summary.mismatched;
            if (data.summary.total > 0) {
                const percent = ((problematic / data.summary.total) * 100).toFixed(1);
                if (problematic === 0) {
                    problematicPercent.textContent = 'All references verified!';
                    problematicPercent.className = 'problematic-percent clean';
                } else {
                    problematicPercent.textContent = `${percent}% of references are problematic (${problematic} of ${data.summary.total})`;
                    problematicPercent.className = 'problematic-percent';
                }
            } else {
                problematicPercent.textContent = '';
            }

            // Show standard summary and hallucinations sections
            document.querySelector('.summary').style.display = 'block';
            document.getElementById('hallucinations').style.display = 'block';

            // Render all results
            const list = document.getElementById('hallucinationList');
            list.innerHTML = '';

            const hallucinations = data.results.filter(r => r.status !== 'verified');
            const verified = data.results.filter(r => r.status === 'verified');

            if (hallucinations.length === 0) {
                list.innerHTML = '<div class="no-hallucinations">All references verified!</div>';
            } else {
                hallucinations.forEach(ref => {
                    list.appendChild(renderHallucination(ref));
                });
            }

            // Show verified references in collapsible section
            if (verified.length > 0) {
                const verifiedSection = document.createElement('div');
                verifiedSection.className = 'verified-section';
                verifiedSection.innerHTML = `
                    <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                        <span>Verified References (${verified.length})</span>
                        <span class="verified-toggle">▼</span>
                    </div>
                    <div class="verified-list"></div>
                `;
                const verifiedList = verifiedSection.querySelector('.verified-list');
                verified.forEach(ref => {
                    const item = document.createElement('div');
                    item.className = 'verified-item';
                    const sourceLink = ref.paper_url
                        ? `<a href="${escapeHtml(ref.paper_url)}" target="_blank" class="verified-source">${escapeHtml(ref.source || 'Unknown')} ↗</a>`
                        : `<span class="verified-source">${escapeHtml(ref.source || 'Unknown')}</span>`;
                    item.innerHTML = `
                        <span class="verified-title">${escapeHtml(ref.title)}</span>
                        ${sourceLink}
                    `;
                    verifiedList.appendChild(item);
                });
                list.appendChild(verifiedSection);
            }
        }

        function renderMultiFileResults(data) {
            // Hide standard single-file sections
            document.querySelector('.summary').style.display = 'none';
            document.getElementById('hallucinations').style.display = 'none';

            const container = document.getElementById('hallucinationList');
            container.innerHTML = '';

            // Add aggregate header
            const header = document.createElement('div');
            header.className = 'multi-file-header';
            const aggProblematic = data.summary.not_found + data.summary.mismatched;
            const aggPercent = data.summary.total > 0 ? ((aggProblematic / data.summary.total) * 100).toFixed(1) : 0;
            const aggPercentClass = aggProblematic === 0 ? 'problematic-percent clean' : 'problematic-percent';
            const aggPercentText = aggProblematic === 0
                ? 'All references verified!'
                : `${aggPercent}% of references are problematic (${aggProblematic} of ${data.summary.total})`;

            header.innerHTML = `
                <h2>Archive Results</h2>
                <div class="file-count">${data.file_count} PDF files processed</div>
                <div class="stats" style="margin-top: 1rem;">
                    <div class="stat">
                        <div class="stat-value">${data.summary.total}</div>
                        <div class="stat-label">Total Analyzed</div>
                    </div>
                    <div class="stat stat-verified">
                        <div class="stat-value">${data.summary.verified}</div>
                        <div class="stat-label">Verified</div>
                    </div>
                    <div class="stat stat-mismatch">
                        <div class="stat-value">${data.summary.mismatched}</div>
                        <div class="stat-label">Mismatches</div>
                    </div>
                    <div class="stat stat-notfound">
                        <div class="stat-value">${data.summary.not_found}</div>
                        <div class="stat-label">Not Found</div>
                    </div>
                </div>
                <div class="${aggPercentClass}">${aggPercentText}</div>
                <div class="timeout-warning" style="margin-top: 0.75rem; padding: 0.5rem 1rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e; font-size: 0.9rem;">
                        ⚠️ DB timeouts: ${data.summary.total_timeouts || 0} (retried ${data.summary.retried_count || 0}, ${data.summary.retry_successes || 0} recovered)
                    </div>
            `;
            container.appendChild(header);

            // Render each file as collapsible section
            data.files.forEach((file, index) => {
                const section = document.createElement('div');
                section.className = 'file-section';

                const hasIssues = file.success && file.results.some(r => r.status !== 'verified');
                const hasError = !file.success;

                let statusBadge = '';
                if (hasError) {
                    statusBadge = '<span class="file-status-badge file-status-error">Error</span>';
                } else if (hasIssues) {
                    const issueCount = file.results.filter(r => r.status !== 'verified').length;
                    statusBadge = `<span class="file-status-badge file-status-issues">${issueCount} issue${issueCount > 1 ? 's' : ''}</span>`;
                } else {
                    statusBadge = '<span class="file-status-badge file-status-ok">All verified</span>';
                }

                // Auto-expand files with issues or errors
                const autoExpand = hasIssues || hasError;

                section.innerHTML = `
                    <div class="file-header" data-index="${index}">
                        <div class="file-header-left">
                            <span class="file-name">${escapeHtml(file.filename)}</span>
                            ${statusBadge}
                        </div>
                        <span class="file-toggle ${autoExpand ? 'expanded' : ''}">&#9660;</span>
                    </div>
                    <div class="file-content ${autoExpand ? 'visible' : ''}" id="file-content-${index}">
                        ${renderFileContent(file)}
                    </div>
                `;

                // Add click handler for toggle
                section.querySelector('.file-header').addEventListener('click', () => {
                    const content = section.querySelector('.file-content');
                    const toggle = section.querySelector('.file-toggle');
                    content.classList.toggle('visible');
                    toggle.classList.toggle('expanded');
                });

                container.appendChild(section);
            });

            // Show the hallucinations container (we're using it for multi-file display)
            document.getElementById('hallucinations').style.display = 'block';
            document.getElementById('hallucinations').querySelector('h2').style.display = 'none';
        }

        function renderFileContent(file) {
            if (!file.success) {
                return `<div class="file-error">Error: ${escapeHtml(file.error)}</div>`;
            }

            const hallucinations = file.results.filter(r => r.status !== 'verified');
            const fileProblematic = file.summary.not_found + file.summary.mismatched;
            const filePercent = file.summary.total > 0 ? ((fileProblematic / file.summary.total) * 100).toFixed(1) : 0;
            const filePercentClass = fileProblematic === 0 ? 'problematic-percent clean' : 'problematic-percent';
            const filePercentText = fileProblematic === 0
                ? 'All references verified!'
                : `${filePercent}% problematic (${fileProblematic} of ${file.summary.total})`;

            let html = `
                <div class="file-summary">
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value">${file.summary.total}</div>
                            <div class="stat-label">Analyzed</div>
                        </div>
                        <div class="stat stat-verified">
                            <div class="stat-value">${file.summary.verified}</div>
                            <div class="stat-label">Verified</div>
                        </div>
                        <div class="stat stat-mismatch">
                            <div class="stat-value">${file.summary.mismatched}</div>
                            <div class="stat-label">Mismatches</div>
                        </div>
                        <div class="stat stat-notfound">
                            <div class="stat-value">${file.summary.not_found}</div>
                            <div class="stat-label">Not Found</div>
                        </div>
                    </div>
                    <div class="${filePercentClass}">${filePercentText}</div>
                    ${file.summary.total_timeouts > 0 ? `
                        <div class="timeout-warning" style="margin-top: 0.5rem; padding: 0.375rem 0.75rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.25rem; color: #92400e; font-size: 0.85rem;">
                            ⚠️ DB timeouts: ${file.summary.total_timeouts} (retried ${file.summary.retried_count}, ${file.summary.retry_successes} recovered)
                        </div>
                    ` : ''}
                </div>
            `;

            if (hallucinations.length === 0) {
                html += '<div class="no-hallucinations">All references verified!</div>';
            } else {
                hallucinations.forEach(ref => {
                    const div = document.createElement('div');
                    div.appendChild(renderHallucination(ref));
                    html += div.innerHTML;
                });
            }

            // Add verified references section
            const verified = file.results.filter(r => r.status === 'verified');
            if (verified.length > 0) {
                html += `
                    <div class="verified-section">
                        <div class="verified-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span>Verified References (${verified.length})</span>
                            <span class="verified-toggle">▼</span>
                        </div>
                        <div class="verified-list">
                            ${verified.map(ref => `
                                <div class="verified-item">
                                    <span class="verified-title">${escapeHtml(ref.title)}</span>
                                    ${ref.paper_url
                                        ? `<a href="${escapeHtml(ref.paper_url)}" target="_blank" class="verified-source">${escapeHtml(ref.source || 'Unknown')} ↗</a>`
                                        : `<span class="verified-source">${escapeHtml(ref.source || 'Unknown')}</span>`
                                    }
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function resetProgressUI() {
            liveResults = [];
            totalRefs = 0;
            isArchive = false;
            archiveFileCount = 0;
            currentFileIndex = 0;
            currentFilename = '';
            progressBar.style.width = '0%';
            progressStatus.textContent = 'Extracting references...';
            progressCurrent.textContent = '';
            progressResults.innerHTML = '';
            progressHeaderText.textContent = 'Analyzing references...';
        }

        function addProgressResult(data) {
            const item = document.createElement('div');
            item.className = 'progress-result-item';

            let statusClass = '';
            let statusText = '';
            if (data.status === 'verified') {
                statusClass = 'progress-result-verified';
                statusText = `VERIFIED (${data.source})`;
            } else if (data.status === 'author_mismatch') {
                statusClass = 'progress-result-mismatch';
                statusText = `MISMATCH (${data.source})`;
            } else {
                statusClass = 'progress-result-notfound';
                statusText = 'NOT FOUND';
            }

            const shortTitle = data.title.length > 50 ? data.title.substring(0, 50) + '...' : data.title;
            item.innerHTML = `<span class="${statusClass}">[${data.index + 1}/${data.total}]</span> ${escapeHtml(shortTitle)} - <span class="${statusClass}">${statusText}</span>`;

            progressResults.appendChild(item);
            progressResults.scrollTop = progressResults.scrollHeight;
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(form);
            const fileInput = document.getElementById('pdfFile');
            const file = fileInput.files[0];

            if (!file) {
                errorMessage.textContent = 'Please select a file';
                errorMessage.classList.add('visible');
                return;
            }

            // Save API keys to localStorage
            const openalexKeyValue = openalexKeyInput.value.trim();
            if (openalexKeyValue) {
                localStorage.setItem('openalexKey', openalexKeyValue);
            } else {
                localStorage.removeItem('openalexKey');
            }
            const s2KeyValue = s2ApiKeyInput.value.trim();
            if (s2KeyValue) {
                localStorage.setItem('s2ApiKey', s2KeyValue);
            } else {
                localStorage.removeItem('s2ApiKey');
            }

            // Reset UI
            submitBtn.disabled = true;
            resetProgressUI();
            progressSection.classList.add('visible');
            errorMessage.classList.remove('visible');
            results.classList.remove('visible');

            // Use SSE for all uploads (PDFs and archives)
            try {
                const response = await fetch('/analyze/stream', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Analysis failed');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                // Process SSE events - split by double newline
                function processEvent(eventText) {
                    const lines = eventText.trim().split('\n');
                    let eventType = null;
                    let eventData = null;

                    for (const line of lines) {
                        if (line.startsWith('event:')) {
                            eventType = line.substring(6).trim();
                        } else if (line.startsWith('data:')) {
                            try {
                                eventData = JSON.parse(line.substring(5).trim());
                            } catch (e) {
                                console.error('Failed to parse SSE data:', line);
                            }
                        }
                    }

                    if (!eventType || !eventData) return;

                    console.log('SSE event:', eventType, eventData);
                    if (eventData && eventData.summary) {
                        console.log('Summary data:', eventData.summary);
                        console.log('total_timeouts:', eventData.summary.total_timeouts);
                    }

                    if (eventType === 'archive_start') {
                        isArchive = true;
                        archiveFileCount = eventData.file_count;
                        progressHeaderText.textContent = `Processing ${archiveFileCount} files...`;
                        progressStatus.textContent = `Archive with ${archiveFileCount} PDFs`;
                    } else if (eventType === 'file_start') {
                        currentFileIndex = eventData.file_index;
                        currentFilename = eventData.filename;
                        liveResults = []; // Reset for new file
                        totalRefs = 0;
                        if (isArchive) {
                            progressHeaderText.textContent = `File ${currentFileIndex + 1}/${archiveFileCount}: ${currentFilename}`;
                            // Add file separator in results
                            const separator = document.createElement('div');
                            separator.className = 'progress-result-item';
                            separator.innerHTML = `<strong style="color: #2563eb;">--- ${escapeHtml(currentFilename)} ---</strong>`;
                            progressResults.appendChild(separator);
                            progressResults.scrollTop = progressResults.scrollHeight;
                        }
                        progressStatus.textContent = 'Extracting references...';
                    } else if (eventType === 'file_complete') {
                        if (isArchive) {
                            const fc = eventData;
                            if (fc.success) {
                                progressStatus.textContent = `File ${currentFileIndex + 1}/${archiveFileCount} complete: ${fc.summary.verified} verified, ${fc.summary.not_found} not found`;
                            } else {
                                progressStatus.textContent = `File ${currentFileIndex + 1}/${archiveFileCount} failed: ${fc.error}`;
                            }
                            // Update overall progress bar based on files completed
                            const filePct = ((currentFileIndex + 1) / archiveFileCount) * 100;
                            progressBar.style.width = filePct + '%';
                        }
                    } else if (eventType === 'extraction_complete') {
                        totalRefs = eventData.total_refs;
                        const prefix = isArchive ? `[${currentFilename}] ` : '';
                        progressStatus.textContent = `${prefix}Found ${totalRefs} references to check`;
                        if (!isArchive) {
                            progressHeaderText.textContent = `Checking ${totalRefs} references...`;
                        }
                    } else if (eventType === 'retry_pass') {
                        progressStatus.textContent = `Retrying ${eventData.count} references that had timeouts...`;
                        progressHeaderText.textContent = `Retry pass...`;
                    } else if (eventType === 'checking') {
                        const shortTitle = eventData.title.length > 60
                            ? eventData.title.substring(0, 60) + '...'
                            : eventData.title;
                        progressCurrent.textContent = `[${eventData.index + 1}/${eventData.total}] Checking: "${shortTitle}"`;
                        // For single PDF, update progress bar based on refs; for archive, keep file-based progress
                        if (!isArchive) {
                            const pct = ((eventData.index) / eventData.total) * 100;
                            progressBar.style.width = pct + '%';
                        }
                    } else if (eventType === 'result') {
                        liveResults.push(eventData);
                        addProgressResult(eventData);

                        // Update status with running totals
                        const verified = liveResults.filter(r => r.status === 'verified').length;
                        const notFound = liveResults.filter(r => r.status === 'not_found').length;
                        const mismatch = liveResults.filter(r => r.status === 'author_mismatch').length;

                        if (!isArchive) {
                            const pct = ((eventData.index + 1) / eventData.total) * 100;
                            progressBar.style.width = pct + '%';
                            progressStatus.textContent = `Checked ${eventData.index + 1}/${eventData.total}: ${verified} verified, ${notFound} not found, ${mismatch} mismatched`;
                        } else {
                            progressStatus.textContent = `[${currentFilename}] ${eventData.index + 1}/${eventData.total}: ${verified} verified, ${notFound} not found, ${mismatch} mismatched`;
                        }
                    } else if (eventType === 'warning') {
                        // Display warning about failed databases
                        const warningItem = document.createElement('div');
                        warningItem.className = 'progress-result-item';
                        warningItem.innerHTML = `
                            <span style="color: #d97706;">⚠️ [${eventData.index + 1}/${eventData.total}]</span>
                            <span style="color: #92400e;">${escapeHtml(eventData.message)}</span>
                        `;
                        progressResults.appendChild(warningItem);
                        progressResults.scrollTop = progressResults.scrollHeight;
                    } else if (eventType === 'complete') {
                        // Analysis complete - render full results
                        progressSection.classList.remove('visible');

                        // Reset the hallucinations header visibility
                        document.getElementById('hallucinations').querySelector('h2').style.display = 'block';

                        // Check if this is a multi-file result
                        if (eventData.files && eventData.file_count > 1) {
                            renderMultiFileResults(eventData);
                        } else {
                            renderSingleFileResults({
                                summary: eventData.summary,
                                results: eventData.results,
                            });
                        }

                        results.classList.add('visible');
                    } else if (eventType === 'error') {
                        throw new Error(eventData.message || 'Analysis failed');
                    }
                }

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // SSE events are separated by double newlines
                    const events = buffer.split('\n\n');
                    buffer = events.pop(); // Keep incomplete event in buffer

                    for (const eventText of events) {
                        if (eventText.trim()) {
                            processEvent(eventText);
                        }
                    }
                }

            } catch (err) {
                progressSection.classList.remove('visible');
                errorMessage.textContent = err.message;
                errorMessage.classList.add('visible');
            } finally {
                submitBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
